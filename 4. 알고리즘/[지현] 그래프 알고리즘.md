## 그래프 알고리즘

### 그래프

**1) 그래프 정의**

​    정점과 간선으로 구성된 자료구조.



**2) 그래프 기초 용어**

* 정점(Vertex , Node) :
* 간선(Edge, Link): 그래프에서 각 정점들을 연결하는 선.

* 가중치(Weight): 해당 간선을 타고 이동할 때 필요한 비용



**3) 그래프 종류**

* 무방향 그래프: 두 정점을 연결하는 간선에 방향이 없는 그래프.
* 방향 그래프: 두 정점을 연결하는 간선에 방향이 존재하는 그래프. 간선의 방향으로만 이동 가능.
* 가중치 그래프: 간선에 가중치가 할당된 그래프.
* 완전 그래프: 모든 정점이 간선으로 연결되어 있는 그래프.

-----

### 그래프 표현 방법

**1) 인접행렬**

![Adjacency Materix](https://blog.kakaocdn.net/dn/7RFhy/btqKkOhoYiE/SE3IQP2q0g3xd34EQZkjM1/img.png)

* **정의**

  그래프의 노드를 2차원 배열로 표현.

  int형의 2차원 배열을 주로 이용하며, 이동할 수 있으면 1**, **없으면 0으로 표기하는 방식으로 구현한다.

* **장점**

  직관적이며 구현이 비교적 간편하다.

  2차원 배열 안에 모든 정점들의 간선 정보를 담기 때문에 배열의 위치를 확인하면 두 점에 대한 연결 정보를 조회할 때 O(1) 의 시간 복잡도로 가능하다.

* **단점**

  무조건 2차원 배열이 필요하기에 메모리가 낭비된다.

  모든 정점에 대해 간선 정보를 대입해야 하므로 O(n²) 의 시간복잡도가 소요된다.

  

**2) 인접리스트**

![Adjacency List](https://blog.kakaocdn.net/dn/Nlh1G/btqKicb2Wub/sHWVSS6bn2FZdijEJVR2r1/img.png)

* **정의**

  그래프의 노드를 리스트로 표현. 

  리스트(List)나 벡터(Vector)등의 자료구조를 이용하여 각 정점에서 이동가능한 정점들을 저장하는 방식으로 구현한다.

* **장점**

  정점들의 연결 정보를 탐색할 때 O(n) 의 시간이면 가능하다.

  필요한 만큼의 공간만 사용하기때문에  메모리 절약이 가능하다.

* **단점**

  인접행렬 대비 구현이 비교적 어렵다.

  특정 두 점이 연결되었는지 확인하려면 인접행렬에 비해 시간이 오래 걸린다.

  

**3) 간선리스트**

* **정의**

  간선에 대한 정보를 리스트로 표현.

  가장 간단하게 구현되지만 한 정점의 간선에 대한 정보를 얻으려면 모든 간선리스트를 탐색해야 하기 때문에 벨만-포드 알고리즘과 크루스칼 알고리즘 같은 일부 알고리즘이 아니고서야 많이 사용되지는 않는다.

-----

### 그래프 탐색 알고리즘

**1) 깊이 우선 탐색 (Depth First Search, DFS)**

![DFS](https://blog.kakaocdn.net/dn/pOZsh/btqKoqt7HFW/kc36esgGv882I5s7trIuD1/img.gif)

* **정의**

  시작정점을 방문한 후 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하고 넘어가는 방법. 즉, 해당 정점의 자식들을 우선적으로 탐색하는 방법이다.

  간단히 재귀호출을 사용하여 구현하거나 스택을 사용하여 구현한다. 구현 시 정점의 방문여부를 기록하지 않으면 무한루프에 빠질 수 있다.

* **장점**

  현재 경로상의 노드들만 기억하면 되므로, 저장 공간의 수요가 비교적 적음.
  목표 노드가 깊은 단계에 있는 경우 해를 빨리 구할 수 있음.
  구현이 너비 우선 탐색(BFS) 보다 간단함

* **단점**

  단순 검색 속도는 너비 우선 탐색(BFS) 보다 느림 .
  깊이 우선 탐색은 해를 구하면 탐색이 종료되므로, 구한 해가 최단 경로가 된다는 보장이 없음. (목표에 이르는 경로가 다수인 경우 구한 해가 최적이 아닐 수 있음)

  

**2) 너비 우선 탐색 (Breadth First Search, BFS)**

![BFS](https://blog.kakaocdn.net/dn/bLMK90/btqKrJ9aUXI/hvWf1krFJb6R0WlIKx1Vk0/img.gif)

* **정의**

  시작정점을 방문한 후 시작 정점에 인접한 모든 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법. 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회함으로써 정점을 넓게(wide) 탐색한다. 

  주로 두 정점 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 사용하며, 일반적으로 Queue를 사용해서 인접 정점을 넣고 차례대로 꺼내는 방식으로 구현한다.

* **장점**

  정점의 수가 적고 깊이가 얕은 경우 빠르게 동작할 수 있다.

  단순 검색 속도가 깊이 우선 탐색(DFS)보다 빠르다.

  너비를 우선 탐색하기에 답이 되는 경로가 여러개인 경우에도 최단경로임을 보장한다.

  최단경로가 존재한다면 어느 한 경로가 무한히 깊어진다해도 최단경로를 반드시 찾을 수 있다.

* **단점**

  재귀호출의 DFS와는 달리 큐에 다음에 탐색할 정점들을 저장해야 하므로 저장공간이 많이 필요하다.
  정점의 수가 늘어나면 탐색해야하는 정점 또한 많아지기에 비현실적이다.

-----

### 최소 신장 트리 (Minimum Spanning Tree, MST)

**1) 신장 트리 (Spanning Tree)**

그래프에서 일부 간선을 선택해서 만든 최소 연결 부분 그래프.

원래의 그래프의 모든 노드가 연결되어 있으면서 트리의 속성을 만족한다.

**신장 트리의 조건**

* 본래의 그래프의 모든 노드를 포함
* 모든 노드가 서로 연결
* 트리의 속성을 만족시킴 (사이클이 존재하지 않음)



**2) 최소 신장 트리 (Minimum Spanning Tree)**

신장 트리 중에서 사용된 간선들의 가중치 합이 최소인 트리.



**3) 프림 알고리즘 (Prim Algorithm)**

시작 정점을 기준으로 가장 작은 간선과 연결된 정점을 선택하며 신장 트리를 확장 시키는 알고리즘.

임의의 정점에 연결된 간선 중 가장 가중치가 작은 간선을 선택하고, 모든 정점이 선택될 때까지 이 과정을 반복한다.



**4) 크루스칼 알고리즘 (Kruskal Algorithm)**

가장 적은 비용으로 모든 노드를 연결하기 위해 사용하는 알고리즘

간선 리스트를 가중치에 따라 오름차순으로 정렬한 다음 가중치가 가장 작은 간선을 선택하여 두 정점이 연결되어있지 않다면 두 정점을 union해서 연결하는 방식(단, 사이클이 발생하면 포함하지 않는다)을 반복한다.



**4) 크루스칼 VS 프림**

- 프림은 정점 위주의 알고리즘, 크루스칼은 간선 위주의 알고리즘
- 프림은 시작점을 정하고, 시작점에서 가까운 정점을 선택하면서 트리르 구성 하므로 그 과정에서 사이클을 이루지 않지만 크루스칼은 시작점을 따로 정하지 않고 최소 비용의 간선을 차례로 대입 하면서 트리를 구성하기 때문에 사이클이 이루어지는 항상 확인 해야한다.
- 프림의 경우 최소 거리의 정점을 찾는 부분에서 자료구조의 성능에 영향을 받는다.
- 크루스칼은 간선을 기준으로 정렬하는 과정이 오래 걸린다.
- Prim 시간 복잡도: O(n^2),  Kruskal 시간 복잡도: O(elog₂e)

* 그래프 내에 적은 숫자의 간선만을 가지는 희소 그래프(Sparse Graph)의 경우 Kruskal 알고리즘이 적합하고, 그래프에 간선이 많이 존재하는 밀집 그래프(Dense Graph) 의 경우는 Prim 알고리즘이 적합하다.

-----

### 최단 경로 알고리즘

주어진 그래프에서 두 정점을 연결하는 가장 짧은 경로의 길이를 찾는 문제

최단거리 문제는 가중치 유무에 따라, 가중치가 있을 경우엔 가중치의 음양에 따라 알맞은 알고리즘을 사용한다.

- 양의 가중치만 있을 때 : 다익스트라

- 음의 가중치만 있을 때 : 벨만포드

- n 대 n의 최단거리를 모두 구하고 싶을 때 : 플로이드와샬

  

**1) 다익스트라 (Dijkstra Algorithm)**

시작 정점에서부터 인접한 정점들을 하나씩 방문하며 해당 정점까지의 거리(가중치의 합)를 갱신을 최소값으로 갱신시켜나가는 방식

일반적으로 큐 대신 최소 힙(PriorityQueue; 우선순위 큐)을 사용하여 시간을 단축시킨다.

일반 큐를 이용하면 O(V^2)의 시간이 소요되는 반면, 최소 힙을 사용하면 O(Vlog⁡V)의 시간 안으로 끝낼 수 있다. (일반적으로 거의 모든 경우에 최소 힙을 사용한다.)

단, 음이 아닌 가중치에 대해서만 사용이 가능하다는 점에 유의해야 한다. 음수 가중치를 고려하지 않으므로 가중치의 합이 최단거리를 좌우한다. 



**2) 벨만-포드(Bellman-Ford Algorithm)**

벨만-포드 알고리즘은 그래프 내에 음수 가중치를 갖는 간선이 있는 경우에도 활용할 수 있으며 경로 중에 음수 사이클이 존재하는 경우를 피해 최단 거리를 계산 가능하다.

그래프의 정점의 개수를 *V*라고 할 때, 인접 간선을 검사하고 거리 값을 최소로 갱신하는 과정을 V−1번으로 제한하는 방식을 사용한다. 그래프에서 시작 정점에서 특정 정점까지 도달하기 위해 거쳐가는 최대 간선 수는 *V*−1개 이기 때문에 그 이상의 간선이 추가되면 음수 사이클로 인지하고 피할 수 있다.

*V*−1번 인접한 모든 간선들을 검사하는 과정을 거치기 때문에 벨만-포드 알고리즘의 시간 복잡도는 *O*(V^2)가 된다.



**3) 플로이드-와샬 (Floyd-Warshall Algorithm)**

모든 정점에서 각 정점까지의 최단거리를 구하는 알고리즘이다.

경유하는 정점에 초점을 두고, 그 정점을 거쳐가는 경로가 기존 경로보다 더 효율적인지를 판단한다. 즉, 경유하는 정점의 입장에서 어떤 정점 u가 다른 정점 v로 갈 때 자신을 거쳐서 가는 것이 기존의 경로보다 더 효율적이라면 기존의 경로를 갱신해주는 작업을 반복한다.

3중 For문을 이용하여 각 정점마다 다른 정점까지의 최단 거리를 모든 정점에 대해 구하기 때문에, 모든 정점들의 최단거리를 모두 파악할 수 있지만 O(V^3)의 시간이 걸린다.

그러나 양과 음의 모든 가중치에 대해 계산이 가능하고, 4줄밖에 안되는 코드라는 단순함 때문에 자주 이용된다.

-----

### Union Find

**1) 서로소 집합**

서로 중복되지 않는 부분 집합들 로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조.

즉, 공통 원소가 없는, 즉 “상호 배타적” 인 부분 집합들로 나눠진 원소들에 대한 자료구조이다.



**2) Union-Find**

서로소 집합을 표현하는데 쓰이며, 여러 노드가 존재할 때, 두 개의 노드를 선택해서, 현재 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘이다.

**Union-Find 연산**

* Make-set (초기화): N 개의 원소가 각각의 집합에 포함되어 있도록 초기화
* Union (합치기) : 두 원소 a, b 가 주어질 때, 이들이 속한 두 집합을 하나로 합침
* Find (찾기) : 어떤 원소 a 가 주어질 때, 이 원소가 속한 집합을 반환

-----

### Network Flow

특정한 지점에서 다른 지점으로 데이터가 얼마나 많이 흐르고 있는가를 측정하는 알고리즘.

교통 체증, 네트워크 데이터 전송 등의 다양한 분야에 활용되고 있다.

**1) 포드-풀커슨 알고리즘 (Ford-Fulkerson Algorithm)**

**2) 에드몬드 카프 알고리즘 (Edmonds Karp Algorithm)**

-----

**심화 내용**

* 비순환 방향그래프 (Directed Acyclic Graph)
* 그래프 탐색 유형 (미로 탐색 유형 / 정점 이동 유형)
* 백트래킹
* 위상정렬 (Topological Sort)

-----

**참고**

[그래프 기초 용어](https://www.leafcats.com/77)

[그래프 종류](https://velog.io/@dnjscksdn98/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%9E%98%ED%94%84)

[그래프 알고리즘 기초(1)](https://coding-factory.tistory.com/610)

[그래프 알고리즘 기초(2)](https://m.blog.naver.com/occidere/220923695595)

[깊이우선탐색(DFS)](https://coding-factory.tistory.com/611?category=794828)

[너비우선탐색(BFS)](https://coding-factory.tistory.com/612?category=794828)

[최소신장트리(MST)](https://velog.io/@fldfls/%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC-MST-%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

[다익스트라](https://velog.io/@adorno10/%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C1-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BCDijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

[벨만포드](https://velog.io/@adorno10/%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C-2-%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9CBellman-Ford-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

[플로이드와샬](https://velog.io/@adorno10/%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C-3-%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%9B%8C%EC%85%9CFloyd-Warshall-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)

[Union Find](https://travelbeeee.tistory.com/369)

[Network Flow(1)](https://blog.naver.com/ndb796/221237111220)

[Network Flow(2)](https://grini25.tistory.com/172)

[Network Flow(3)](https://soobarkbar.tistory.com/198)

