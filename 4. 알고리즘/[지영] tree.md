<<<<<<< HEAD
# **tree**

# tree? 

- 노드로 이루어진 자료구조입니다.

- 하나의 루트 노드를 갖고 이 루트노드는 0개 이상의 자식 노드를 갖고 있습니다.

  그 자식노드 또한 0개 이상의 자식노드를 갖고 있고 이는 반복적으로 나타나는것이 트리입니다.

- 트리에는 사이클이 존재할 수 없습니다.

- 비선형 자료구조로 계층적 관계를 표현합니다.

# 트리의 특징

- 그래프의 한 종류입니다.
- 트리는 사이클이 존재하지 않으며 계층 모델 입니다.
- 노드가 N개인 트리는 항상 N-1개의 간선(edge)을 가집니다.
  즉, 간선은 항상 (정점의 개수 - 1) 만큼을 가진다는 의미.
- 루트에서 어떤 노드로 가는 경로는 유일합니다.
  임의의 두 노드 간의 경로도 유일합니다. 즉, 두 개의 정점 사이에 반드시 1개의 경로만을 가진다는 의미입니다.
- 한 개의 루트 노드만이 존재하며 모든 자식 노드는 한 개의 부모 노드만을 가집니다.
- 부모-자식 관계이므로 흐름은 top-bottom 아니면 bottom-top으로 이루어집니다.
- 순회는 Pre-order(전위), In-order(중위) 아니면 Post-order(후위)로 이루어집니다. 이 3가지 모두 DFS/BFS 안에 있습니다.
- 트리는 이진 트리, 이진 탐색 트리, 균형 트리(AVL 트리, red-black 트리), 이진 힙(최대힙, 최소힙) 등이 있습니다.



# 이진트리

- 각 노드가 최대 두 개의 자식을 갖는 트리를 말합니다. 모든 트리가 이진 트리인것은 아님(자식 한개만 갖을수도 있으니까)

  - ## 이진트리 순회방식

    - 전위순회: 자기자신 -> 왼쪽 자식노드 -> 오른쪽 자식노드
    - 중위순회: 왼쪽 자식노드 -> 자기자신 -> 오른쪽 자식노드
    - 후위순회: 왼쪽 자식노드 -> 오른쪽 자식노드 -> 자기자신

    

  - ## 완전 이진트리

    - 트리의 마지막 레벨 제외하고 트리의 모든 높이에서 노드들이 꽉 차 있는 이진트리를 말합니다. 마지막 레벨을 꽉 차있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져 있는 모양새여야 합니다.

    

  - ## 전 이진트리

    - 모든 노드가 0개 혹은 2개의 자식 노드를 갖는 이진트리를 말합니다.

    

  - ## 포화 이진트리

    - 전 이진트리이면서 완전 이진트리인 경우를 말합니다.
    - 노드의 갯수가 정확히 2^(n-1)개여야 합니다. 여기서 n은 트리의 높이

# 이진탐색트리(Binary Search Tree)

- 모든 노드가 모든왼쪽자식 <= 노드 < 모든오른쪽자식 에 대해 반드시 참인 이진트리

- 이진탐색과 연결리스트를 결합한 자료구조의 일종입니다. 이진탐색의 효율적인 탐색 능력을 유지하면서도, 빈번한 자료 입력과 삭제를 가능하게끔 고안됐습니다.

- 모든 노드의 키는 유일하다. // 중복된 데이터를 갖는 노드가 없다는 뜻이다. 여기서 키의 의미는 노드 안에 들어 있는 데이터 값을 의미한다.

  왼쪽 서브 트리의 키들은 루트의  키보다 작다. // 예를 들어 루트노드의 데이터가 5라고 하면, 왼쪽 서브트리에는 무조건 5보다 작은 값들만 존재해야 한다.

  오른쪽 서브 트리의 키들은 루트의 키보다 크다. // 위와 같은 원리로 오른쪽에는 루트의 데이터 값보다 더 큰 값들만 존재한다.

  왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다. // 순환적으로 정의되었다는 뜻이다. 즉 왼쪽 서브트리로 내려가든, 오른쪽 서브트리로 내려가든 동일한 법칙이 적용된다는 뜻이다.

- 이진탐색트리의 높이를 h라 할 때 이진탐색트리의 탐색/삽입/삭제의 시간복잡도는 O(h)? O(logN)? (진실은 뭘까) 입니다.

- 이진탐색트리를 순회할 때는 중위순회 방식을 씁니다. 중위순회로 탐색할 경우 이진탐색트리 내에 있는 모든 값들을 정렬된 순서대로 읽을 수 있습니다.

- 각종 연산의 시간복잡도는 O(h).

- 최악의 경우(한쪽으로만 계속 늘어지는 구조가 될 경우) 트리의 높이 h는 O(n).

  - 실제 위에서 학습한 BST의 Search, Insert, Delete 모두 최악의 경우 시간복잡도는 O(n).
  - 그러나, 이것은 실제 최악의 경우에 해당한다. BST에 데이터들이 random하게 구성된다고 가정했을때, 평균 트리의 높이는 O(logn)이 된다. 이는 Search, Insert, Delete 연산의 시간복잡도가 O(logn)이 된다는 이야기 ????.

- 최악의 경우에도 O(logn)을 넘지 않도록 하는 균형잡힌 트리: 레드블랙트리 

- ![스크린샷 2021-06-19 오후 9.12.35](/Users/jeeyoungkim/Desktop/github/TIL/image/스크린샷 2021-06-19 오후 9.12.35.png)






# B+ tree?

- 리프 노드에만 key와 데이터를 저장하고 리프노드끼리 linked list로 연결되어있습니다.
- 전체 검색 시 리프 노드에 모든 데이터가 있기 때문에 한번의 선형 탐색으로만 원하는 데이터를 찾을 수 있어 B-tree에 비해 빠릅니다.



# AVL tree?

- 밸런스 팩터의 개념을 도입하여 서브트리의 높이를 적절하게 제어해서 전체 트리가 어느 한쪽으로 늘어지지 않도록 한 이진탐색트리의 일종입니다.

# Top-Down방식이란? 

- 가장 큰 문제를 방문 후 작은 문제를 호출 하여 답을 찾는 방식입니다.(재귀 호출을 이용)      
- 점화식을 이해하기 쉽다는 장점이 있습니다.(ex)피보나치 수열) 

# BOTTOM-UP방식이란? 

- 가장 작은 문제들 부터 답을 구해가며 전체 문제의 답을 찾는 방식이다.(반복문을 이용) 	
- 재귀 호출하지 않기 때문에 메모리 사용량을 줄일 수 있다는 장점이 있습니다.





------

** 출처

트리, 트리의 특징, 이진트리, 완전이진트리, 전이진트리, 포화이진트리: https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html

이진탐색트리: https://mattlee.tistory.com/30

이진탐색트리 시간복잡도 참고: **https://ict-nroo.tistory.com/63**
=======
# **tree**

# tree? 

- 노드로 이루어진 자료구조입니다.

- 하나의 루트 노드를 갖고 이 루트노드는 0개 이상의 자식 노드를 갖고 있습니다.

  그 자식노드 또한 0개 이상의 자식노드를 갖고 있고 이는 반복적으로 나타나는것이 트리입니다.

- 트리에는 사이클이 존재할 수 없습니다.

- 비선형 자료구조로 계층적 관계를 표현합니다.

# 트리의 특징

- 그래프의 한 종류입니다.
- 트리는 사이클이 존재하지 않으며 계층 모델 입니다.
- 노드가 N개인 트리는 항상 N-1개의 간선(edge)을 가집니다.
  즉, 간선은 항상 (정점의 개수 - 1) 만큼을 가진다는 의미.
- 루트에서 어떤 노드로 가는 경로는 유일합니다.
  임의의 두 노드 간의 경로도 유일합니다. 즉, 두 개의 정점 사이에 반드시 1개의 경로만을 가진다는 의미입니다.
- 한 개의 루트 노드만이 존재하며 모든 자식 노드는 한 개의 부모 노드만을 가집니다.
- 부모-자식 관계이므로 흐름은 top-bottom 아니면 bottom-top으로 이루어집니다.
- 순회는 Pre-order(전위), In-order(중위) 아니면 Post-order(후위)로 이루어집니다. 이 3가지 모두 DFS/BFS 안에 있습니다.
- 트리는 이진 트리, 이진 탐색 트리, 균형 트리(AVL 트리, red-black 트리), 이진 힙(최대힙, 최소힙) 등이 있습니다.



# 이진트리

- 각 노드가 최대 두 개의 자식을 갖는 트리를 말합니다. 모든 트리가 이진 트리인것은 아님(자식 한개만 갖을수도 있으니까)

  - ## 이진트리 순회방식

    - 전위순회: 자기자신 -> 왼쪽 자식노드 -> 오른쪽 자식노드
    - 중위순회: 왼쪽 자식노드 -> 자기자신 -> 오른쪽 자식노드
    - 후위순회: 왼쪽 자식노드 -> 오른쪽 자식노드 -> 자기자신

    

  - ## 완전 이진트리

    - 트리의 마지막 레벨 제외하고 트리의 모든 높이에서 노드들이 꽉 차 있는 이진트리를 말합니다. 마지막 레벨을 꽉 차있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져 있는 모양새여야 합니다.

    

  - ## 전 이진트리

    - 모든 노드가 0개 혹은 2개의 자식 노드를 갖는 이진트리를 말합니다.

    

  - ## 포화 이진트리

    - 전 이진트리이면서 완전 이진트리인 경우를 말합니다.
    - 노드의 갯수가 정확히 2^(n-1)개여야 합니다. 여기서 n은 트리의 높이

# 이진탐색트리(Binary Search Tree)

- 모든 노드가 모든왼쪽자식 <= 노드 < 모든오른쪽자식 에 대해 반드시 참인 이진트리

- 이진탐색과 연결리스트를 결합한 자료구조의 일종입니다. 이진탐색의 효율적인 탐색 능력을 유지하면서도, 빈번한 자료 입력과 삭제를 가능하게끔 고안됐습니다.

- 모든 노드의 키는 유일하다. // 중복된 데이터를 갖는 노드가 없다는 뜻이다. 여기서 키의 의미는 노드 안에 들어 있는 데이터 값을 의미한다.

  왼쪽 서브 트리의 키들은 루트의  키보다 작다. // 예를 들어 루트노드의 데이터가 5라고 하면, 왼쪽 서브트리에는 무조건 5보다 작은 값들만 존재해야 한다.

  오른쪽 서브 트리의 키들은 루트의 키보다 크다. // 위와 같은 원리로 오른쪽에는 루트의 데이터 값보다 더 큰 값들만 존재한다.

  왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다. // 순환적으로 정의되었다는 뜻이다. 즉 왼쪽 서브트리로 내려가든, 오른쪽 서브트리로 내려가든 동일한 법칙이 적용된다는 뜻이다.

- 이진탐색트리의 높이를 h라 할 때 이진탐색트리의 탐색/삽입/삭제의 시간복잡도는 O(h)? O(logN)? (진실은 뭘까) 입니다.

- 이진탐색트리를 순회할 때는 중위순회 방식을 씁니다. 중위순회로 탐색할 경우 이진탐색트리 내에 있는 모든 값들을 정렬된 순서대로 읽을 수 있습니다.

- 각종 연산의 시간복잡도는 O(h).

- 최악의 경우(한쪽으로만 계속 늘어지는 구조가 될 경우) 트리의 높이 h는 O(n).

  - 실제 위에서 학습한 BST의 Search, Insert, Delete 모두 최악의 경우 시간복잡도는 O(n).
  - 그러나, 이것은 실제 최악의 경우에 해당한다. BST에 데이터들이 random하게 구성된다고 가정했을때, 평균 트리의 높이는 O(logn)이 된다. 이는 Search, Insert, Delete 연산의 시간복잡도가 O(logn)이 된다는 이야기 ????.

- 최악의 경우에도 O(logn)을 넘지 않도록 하는 균형잡힌 트리: 레드블랙트리 

- ![스크린샷 2021-06-19 오후 9.12.35](/Users/jeeyoungkim/Desktop/github/TIL/image/스크린샷 2021-06-19 오후 9.12.35.png)





# B tree?

- 이진트리를 확장해서 더 많은 수의 자식을 가질 수 있게 일반화한 트리입니다.
- 한 노드에 m개의 노드가 배치되면 m차 B-tree 라고 합니다. 스스로 균형을 맞추는 트리입니다. 그래서 최악의 경우에도 O(logN)의 성능을 보입니다.
- 각 노드에 key뿐만 아니라 data도 들어갈 수 있습니다.

# B+ tree?

- B- tree의 변형 구조로 index부분과 leaf노드로 구성된 순차 data 부분으로 이루어집니다. index 부분의 key 값은 leaf의 key값을 찾아가는데 사용하고 모든 key 값은 leaf노드에 나열됩니다.
- 리프 노드에만 key와 데이터를 저장하고 리프노드끼리 linked list로 연결되어있습니다.
- 전체 검색 시 리프 노드에 모든 데이터가 있기 때문에 한번의 선형 탐색으로만 원하는 데이터를 찾을 수 있어 B-tree에 비해 빠릅니다.



# AVL tree?

- 밸런스 팩터의 개념을 도입하여 서브트리의 높이를 적절하게 제어해서 전체 트리가 어느 한쪽으로 늘어지지 않도록 한 이진탐색트리의 일종입니다.
- 이진탐색트리이면서 균형을 유지하고 있습니다. 모든 노드의 왼쪽과 오른쪽 서브트리의 높이 차이가 1 이하입니다. 균형을 유지하고 있기 때문에 이진 탐색 시 효율성을 보장할 수 있습니다.
- N개의 노드를 가진 트리의 높이가 O(logN)이 되어 탐색, 삽입, 삭제 연산의 수행시간이 O(logN)이 보장됩니다. 평균, 최악이 동일!
- AVL 트리에서는 좌우 높이 차가 1보다 커지면 균형이 무너진 것입니다. 이 균형을 유지하는 방법이 복잡함 -> LL(왼쪽으로 치우친 경우), RR(오른쪽으로 치우친 경우), RL, LR(왼쪽 자식노드에 오른쪽 자식노드만 있는 경우)
- LR
  - ![image-20210708160459833](/Users/jeeyoungkim/Desktop/github/TWL/image/image-20210708160459833.png)



- # Red-black tree?

  - 레드블랙트리는 balanced binary search tree
  - 레드블랙트리가 되기 위한 4가지 조건
    1. 루트노드의 색은 블랙
    2. 모든 external node의 색은 블랙
    3. 레드의 자식은 블랙 == 레드 노드가 연속으로 나올 수 없음
    4. 모든 leaf 노드에서 블랙노드의 깊이는 같다. == leaf 노드에서 루트노드까지 가는 경로에서 만나는 블랙노드의 갯수는 같다 --> 이 조건을 만족시키면 이진탐색트리인 레드블랙트리의 높이를 logN에 바운드되도록 해줌
  - 레드의 자식이 블랙이 아닌 레드인 경우: 더블레드 

  이는 레드블랙트리의 조건에 위반하므로 고쳐줘야된다.

  고치는 방법 1. Restructuring 2. Recoloring

  - ## Restructuring

    - 나, 부모, 조부모 노드를 가지고 Restructuring 진행
    - 1. 나, 부모, 조부모를 오름차순으로 정렬
      2. 무조건 가운데 값을 부모로 만들고 나머지 둘을 자식으로 만듦
      3. 올라간 가운데 값을 블랙으로 만들고 두 자식을 레드로 만듦
    - Restructuring은 다른 서브트리에 영향을 끼치지 않기 때문에 한번의 Restructuring이면 충분! --> 레드블랙트리의 조건 4인 블랙노드의 갯수의 변화는 없기 때문에 가능
    - Restructuring 자체의 시간복잡도는 O(1)
    - 어떤 노드를 insertion한 뒤 일어나므로 총 수행시간은 O(logn)

  - ## Recoloring

    - 나, 부모, 부모의 형제, 조부모 노드를 가지고 Recoloring 진행
    - 부모오ㅏ 부모의 형제노드를 블랙으로, 조부모를 레드로.
    - 조부모가 트리의 루트가 아니었을 시 또 다른 double red가 발생할 수 있다.
    - Recoloring을 위해선는 내 위치를 찾아야됨. 이진탐색트리이므로 검색하는데 O(logn)
    - Recoloring 자체는 O(1), 최악(루트노드를 타고타고 더블레드가 계속 발생할경우)의 경우 O(logn)
    - 따라서 Recoloring의 시간복잡도는 O(logn)

# Top-Down방식이란? 

- 가장 큰 문제를 방문 후 작은 문제를 호출 하여 답을 찾는 방식입니다.(재귀 호출을 이용)      
- 점화식을 이해하기 쉽다는 장점이 있습니다.(ex)피보나치 수열) 

# BOTTOM-UP방식이란? 

- 가장 작은 문제들 부터 답을 구해가며 전체 문제의 답을 찾는 방식이다.(반복문을 이용) 	
- 재귀 호출하지 않기 때문에 메모리 사용량을 줄일 수 있다는 장점이 있습니다.





------

** 출처

트리, 트리의 특징, 이진트리, 완전이진트리, 전이진트리, 포화이진트리: https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html

이진탐색트리: https://mattlee.tistory.com/30

이진탐색트리 시간복잡도 참고: **https://ict-nroo.tistory.com/63**

[B tree, B+ tree](
>>>>>>> 790c977612b31b74f213a6f28e387ea83b790c80
