###### Q. (지영) 트리에 대해 설명해주세요.

A. 트리는 노드로 이루어진 자료구조입니다. 하나의 루트노드와 0개 이상의 자식노드로 구성되어 있고 이게 반복적으로 나타나는것이 트리입니다.



###### Q. (지영) 트리의 특징을 말씀해주세요.

A. 트리는 그래프의 한 종류입니다. 트리에는 사이클이 존재하지 않으며 계층 모델입니다.

노드가 N개인 트리는 항상 N-1개의 간선(edge)을 가집니다.
즉, 간선은 항상 (정점의 개수 - 1) 만큼을 가진다는 말과 동일합니다.

한 개의 루트 노드만이 존재하며 모든 자식 노드는 한 개의 부모 노드만을 가집니다.

또한 루트에서 어떠한 노드로 가는 경로는 유일합니다. 즉 두개의 노드 사이에 단 1개의 경로만을 가집니다.

트리의 순회는 전위, 중위, 후위로 이루어집니다.

트리는 이진트리, 이진탐색트리, 균형트리와 이진힙 등이 존재합니다.



###### Q. (지영) 이진트리가 뭔가요?

A. 이진트리는 각 노드가 최대 두개의 자식을 갖는 트리를 말합니다. 자식을 항상 두개를 갖는것은 아니기 때문에 모든 트리가 이진트리라고 말할 수는 없습니다. 이진트리는 완전 이진트리, 전 이진트리, 포화 이진트리로 나눌 수 있습니다.



###### Q. (지영) 각각의 이진트리에 대해 말해주세요.

A. 완전 이진트리는 트리의 마지막 레벨 제외하고 트리의 모든 높이에서 노드들이 꽉 차 있는 이진트리를 말합니다. 마지막 레벨을 꽉 차있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져 있는 모양새여야 합니다.

전 이진트리는 모든 노드가 0개 혹은 2개의 자식 노드를 갖는 이진트리를 말합니다.

포화 이진트리는 전 이진트리이면서 완전 이진트리인 경우를 말합니다. 그렇기 때문에 노드의 갯수가 정확히  2^(n-1)개입니다 (n은 트리의 높이). 



###### Q. (지영) 이진탐색트리는 뭔가요?

A. 이진탐색과 연결리스트를 결합한 자료구조의 일종입니다. 이진탐색의 효율적인 탐색 능력을 유지하면서도, 빈번한 자료 입력과 삭제를 가능하게끔 고안됐습니다.

모든 노드의 키는 유일하고 왼쪽 서브트리의 키들은 루트의 키보다 작고, 오른쪽 서브트리의 키들은 루트의 키보다 큰 값만 존재하는 트리입니다.

이진탐색트리를 순회할 때는 중위순회 방식을 씁니다. 중위순회로 탐색할 경우 이진탐색트리 내에 있는 모든 값들을 정렬된 순서대로 읽을 수 있습니다



###### Q. (지영) 이진탐색트리의 시간복잡도?

A. 이진탐색트리에서의 탐색/삽입/삭제 연산의 시간복잡도는 트리의 높이를 h라고 했을 때 h에 비례합니다.

최악의 경우는 한쪽으로만 늘어지는 경사 이진트리가 될 때입니다. 이때 이진트리의 높이는 h이고, 시간복잡도는 O(n)입니다.

h=log2n이 되는 이진트리가 균형적으로 생성되어있는 경우의 시간복잡도는 O(logn) 입니다.




###### Q. (지홍) Java Collection Framework가 무엇인가요?

A. Collection은 요소로 알려진 객체 그룹입니다. 기본 인터페이스로는 set, list, map이 있습니다.

set은 중복 요소를 포함할 수 없는 모음입니다.

list는 정렬된 컬렉션으로 중복 요소를 포함 할 수 있습니다.

map은 키를 값에 매핑하여 중복 키를 포함할 수 없는 특징을 가지고 있습니다.



###### Q. (지홍) iterator에 대해서 설명해주세요.

A. literator는 반복자 인터페이스입니다. 컬렉션을 반복할 수 있는 메소드를 제공합니다. java collection은 iterator 메소드를 사용할 수 있습니다.

iterator는 반복하는 가운데 colleciton 요소를 제거할 수 있습니다.



###### Q. (지홍) HashMap의 작동 방법이 무엇인가요?

A. HashpMap은 키와 벨류를 쌍으로 지정합니다. 해싱을 통해 저장하여 사용합니다.



###### Q. (지홍) HashMap과 HashTable의 차이점은 무엇인가요?

A. HashMap은 널키와 널값을 허용하지만, HashTable은 널키나 널값을 허용하지 않습니다.

또한, HashMap은 동기화가 되지 않지만 HashTable은 동기화를 지원합니다.



###### Q. (지홍) ArrayList와 LinkedList의 차이점은 무엇인가요?

A. ArrayList는 인덱스 기반 데이터 구조입니다. 따라서 검색에 O(1)의 속도를 가지고 무작위로 액세스할 수 있습니다. 그러나 LinkedList는 이전과 다음 요소로 연결되는 형태로 검색에 실행 시간이 오래 걸립니다. 삽입, 삭제에는 ArrayList보다 빠르다는 장점을 가지고 있습니다.



###### Q. (지홍) HashSet과 TreeSet의 차이점이 무엇인가요?

A. HashSet은 해시테이블을 이용해 구현하므로 요소들이 정렬되지 않습니다. 따라서, 삽입, 삭제, 검색 등은 O(1)의 시간복잡도를 가집니다.

TreeSet은 트리 구조를 사용하여 구현하므로 요소가 정렬됩니다. 따라서 삽입, 삭제, 검색에 O(logN)의 시간복잡도를 가집니다.



###### Q. (지홍) Stack과 Queue 차이점과 사용예시를 알려주세요.

A. Stack은 선입후출 구조입니다. 입력과 출력이 한 곳에서 나옵니다. 대표적으로는 뒤로가기 구현 시 사용합니다.

Queue는 선입선출 구조로, 입력과 출력이 다른 것입니다. 대표적으로 Cache, 은행 업무 등이 있습니다.



###### Q. (지홍) Vector와 List의 차이점에 대해서 알려주세요.

A. Vector는 요소들이 인접해 있어 임의 접근이 가능하지만, List는 노드가 흩어져 있으므로 양방향으로만 이동이 가능합니다. 따라서, list는 임의 위치를 상수시간 내에 엑세스 할 수 없습니다.



###### Q. (지홍) 해시테이블이 무엇인가요?

A. 해시 테이블은 키와 벨류를 저장한 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용합니다.

해시의 idnex 값에 충돌이 발생한 경우, 충돌된 index 값에 대해 연결된 데이터들을 조회하여 원하는 값을 조회하므로 O(N)까지 시간복잡도가 증가할 수 있습니다.



###### Q. (지현) 그래프 자료구조에 대해 설명해주세요.

A. 그래프는 정점과 간선으로 구성된 자료구조입니다. 

간선의 방향 유무와 가중치 유무, 사이클 유무, 모든 정점이 간선으로 연결되어있는지 여부에 따라 다양한 그래프가 존재합니다.

그래프는 그래프의 노드를 2차원 배열로 표현하는 인접행렬, 그래프의 노드를 리스트로 표현하는 인접리스트, 그래프의 간선에 대한 정보를 리스트로 표현하는 간선리스트로 표현 가능합니다.



###### Q. (지현) 그래프 탐색 알고리즘 두가지를 설명해주세요.

A. 그래프 탐색 알고리즘으로 깊이우선탐색과 너비우선탐색이 있습니다.

첫번째, 깊이우선탐색부터 설명드리겠습니다.

깊이우선탐색은 시작정점을 방문한 후 해당 정점의 자식들을 우선적으로 탐색하는 방법입니다.

재귀호출 또는 스택을 사용하여 구현 가능하며 찾는 노드의 depth가 깊을수록 빠르고, 메모리 소모가 적습니다.

단, 깊이 우선 탐색은 해를 구하면 탐색이 종료되므로, 구한 해가 최단 경로가 된다는 보장이 없습니다.

두번째, 너비우선탐색은 시작정점을 방문한 후 시작 정점에 인접한 모든 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법입니다.

일반적으로 큐를 사용하여 구현합니다. 너비를 우선 탐색하기에 답이 되는 경로가 여러개인 경우에도 최단경로임을 보장하기에 주로 최단경로 찾기에 사용됩니다.

단, DFS와는 달리 큐에 다음에 탐색할 정점들을 저장해야 하므로 메모리소모가 큽니다.



###### Q. (지현) 크루스칼 알고리즘과 프림 알고리즘의 공통점과 차이점을 설명해보세요.

A. 두 알고리즘은 모두 어떤 그래프에서 최소 신장 트리를 만드는 방법이며, 간선이 하나도 없는 상태에서 시작해 하나씩 트리에 간선을 추가해 가는 탐욕적 알고리즘입니다.

이 두 알고리즘의 차이점을 크게 세가지로 나누어 설명드리겠습니다.

첫번째, 프림은 정점 위주의 알고리즘이고, 크루스칼은 간선 위주의 알고리즘입니다.

두번째, 프림은 시작점을 정하고, 시작점에서 가까운 정점을 선택하면서 트리르 구성 하므로 그 과정에서 사이클을 이루지 않지만 크루스칼은 시작점을 따로 정하지 않고 최소 비용의 간선을 차례로 대입 하면서 트리를 구성하기 때문에 사이클이 이루어지는 항상 확인 해야합니다.

세번째, 그래프의 간선 개수가 적다면 크루스칼 알고리즘이 적합하고, 간선 개수가 많다면 프림 알고리즘이 적합합니다.



###### Q. (지현) 최단 경로 알고리즘에는 무엇이 있나요?

A. 최단 경로 알고리즘에는 다익스트라, 벨만포드, 플로이드 와샬이 있습니다.

최단경로 알고리즘은 가중치 유무에 따라, 가중치가 있을 경우엔 가중치의 음양에 따라 알맞은 알고리즘이 존재합니다.

첫번째, 양의 가중치만 있을 때, 가장 시간복잡도가 작은 다익스트라가 가장 적합합니다.

두번째, 음의 가중치만 있을 때, 음수 가중치를 갖는 간선이 있는 경우에도 활용가능한 벨만포드가 적합합니다.

세번째, 한개 이상의 정점에서의 최단거리를 모두 구하고 싶을 때 플로이드와샬을 사용합니다.



###### Q. (지현) 방금 말한 각 알고리즘의 시간복잡도를 알고있나요?

A. 시간복잡도를 표현하기 위해 먼저 간선의 개수를 V라고 정의하겠습니다.

첫번째, 다익스트라의 경우 일반 큐를 이용하면 O(V^2)의 시간복잡도를 나타내며, 최소 힙을 사용하면 O(Vlog⁡V)입니다.

두번째, 벨만포드는 *V*−1번 인접한 모든 간선들을 검사하는 과정을 거치기 때문에 시간 복잡도는 *O*(V^2)입니다.
세번째, 플로이드와샬은 3중 For문을 이용하여 O(V^3)의 시간복잡도를 나타냅니다.



###### Q. (소영) 자바 sort 라이브러리의 소팅 알고리즘은 무엇인지 아세요?

A. Arrays.sort()의 경우 dual pivot quicksort 알고리즘을 사용하고, Collections.sort() 의 경우 insertion sort 와 merge sort를 합친 time sort 알고리즘을 사용합니다.



###### Q. (소영) 머지소트 작동 과정을 설명하실 수 있나요?

A.  먼저 리스트를 두 개의 균등한 부분 집합으로 나누고 각 부분 집합을 정렬합니다. 다음 각 부분 집합들을 정렬하여 다시 정렬된 형태로 합쳐 정렬을 완성합니다.



###### Q. (소영) 퀵소트 작동 과정을 설명하실 수 있나요?

A.  먼저 리스트 안에서 한 요소를 선택합니다. 여기서 선택된 요소를 pivot이라고 칭합니다. 피벗을 기준으로 작은 요소는 왼쪽으로 큰 요소는 오른쪽으로 옮깁니다. 좌우로 이분화된 리스트를 재귀적으로 반복하여 정렬을 완성합니다.



###### Q. (소영) 퀵소트 시간 복잡도는 어떻게 되는지 아세요?

A.  평균과 최선의 경우엔 nlogn, 최악의 경우엔 n^2의 시간복잡도를 가지게 됩니다.



###### Q. (소영) 그렇다면 퀵소트의 최악의 경우 개선 방안을 설명해주세요

A. 첫번째로 피봇이 항상 편향되는 최악의 경우를 막기 위해 피봇값을 매번 랜덤한 위치로 잡는 방법이 있습니다. 두번째로 배열의 가장 첫 인덱스, 끝 인덱스, 중간 인덱스에 해당하는 값들을 정렬하고, 중간 값을 Pivot으로 사용하여 Quick Sort를 수행하는 방법이 있습니다.
