###### Q. (지영) 트리에 대해 설명해주세요.

A. 트리는 노드로 이루어진 자료구조입니다. 하나의 루트노드와 0개 이상의 자식노드로 구성되어 있습니다. 사이클이 존재할 수 없습니다.



###### Q. (지영) 트리의 특징을 말씀해주세요.

A. 트리는 그래프의 한 종류입니다. 트리에는 사이클이 존재하지 않으며 계층 모델입니다.

또한 루트에서 어떠한 노드로 가는 경로는 유일합니다. 즉 두개의 노드 사이에 단 1개의 경로만을 가집니다.

트리의 순회는 전위, 중위, 후위로 이루어집니다.

트리는 이진트리, 이진탐색트리, 균형트리와 이진힙 등이 존재합니다.



###### Q. (지영) 이진트리가 뭔가요?

A. 이진트리는 각 노드가 최대 두개의 자식을 갖는 트리를 말합니다.



###### Q. (지영) 이진탐색트리는 뭔가요?

A. 



###### Q. (지영) 이진탐색트리의 시간복잡도?

A. 



###### Q. (지현) 그래프 자료구조에 대해 설명해주세요.

A. 그래프는 정점과 간선으로 구성된 자료구조입니다. 

간선의 방향 유무와 가중치 유무, 사이클 유무, 모든 정점이 간선으로 연결되어있는지 여부에 따라 다양한 그래프가 존재합니다.

그래프는 그래프의 노드를 2차원 배열로 표현하는 인접행렬, 그래프의 노드를 리스트로 표현하는 인접리스트, 그래프의 간선에 대한 정보를 리스트로 표현하는 간선리스트로 표현 가능합니다.



###### Q. (지현) 그래프 탐색 알고리즘 두가지를 설명해주세요.

A. 그래프 탐색 알고리즘으로 깊이우선탐색과 너비우선탐색이 있습니다.

첫번째, 깊이우선탐색부터 설명드리겠습니다.

깊이우선탐색은 시작정점을 방문한 후 해당 정점의 자식들을 우선적으로 탐색하는 방법입니다.

재귀호출 또는 스택을 사용하여 구현 가능하며 찾는 노드의 depth가 깊을수록 빠르고, 메모리 소모가 적습니다.

단, 깊이 우선 탐색은 해를 구하면 탐색이 종료되므로, 구한 해가 최단 경로가 된다는 보장이 없습니다.

두번째, 너비우선탐색은 시작정점을 방문한 후 시작 정점에 인접한 모든 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법입니다.

일반적으로 큐를 사용하여 구현합니다. 너비를 우선 탐색하기에 답이 되는 경로가 여러개인 경우에도 최단경로임을 보장하기에 주로 최단경로 찾기에 사용됩니다.

단, DFS와는 달리 큐에 다음에 탐색할 정점들을 저장해야 하므로 메모리소모가 큽니다.



###### Q. (지현) 크루스칼 알고리즘과 프림 알고리즘의 공통점과 차이점을 설명해보세요.

A. 두 알고리즘은 모두 어떤 그래프에서 최소 신장 트리를 만드는 방법이며, 간선이 하나도 없는 상태에서 시작해 하나씩 트리에 간선을 추가해 가는 탐욕적 알고리즘입니다.

이 두 알고리즘의 차이점을 크게 세가지로 나누어 설명드리겠습니다.

첫번째, 프림은 정점 위주의 알고리즘이고, 크루스칼은 간선 위주의 알고리즘입니다.

두번째, 프림은 시작점을 정하고, 시작점에서 가까운 정점을 선택하면서 트리르 구성 하므로 그 과정에서 사이클을 이루지 않지만 크루스칼은 시작점을 따로 정하지 않고 최소 비용의 간선을 차례로 대입 하면서 트리를 구성하기 때문에 사이클이 이루어지는 항상 확인 해야합니다.

세번째, 그래프의 간선 개수가 적다면 크루스칼 알고리즘이 적합하고, 간선 개수가 많다면 프림 알고리즘이 적합합니다.



###### Q. (지현) 최단 경로 알고리즘에는 무엇이 있나요?

A. 최단 경로 알고리즘에는 다익스트라, 벨만포드, 플로이드 와샬이 있습니다.

최단경로 알고리즘은 가중치 유무에 따라, 가중치가 있을 경우엔 가중치의 음양에 따라 알맞은 알고리즘이 존재합니다.

첫번째, 양의 가중치만 있을 때, 가장 시간복잡도가 작은 다익스트라가 가장 적합합니다.

두번째, 음의 가중치만 있을 때, 음수 가중치를 갖는 간선이 있는 경우에도 활용가능한 벨만포드가 적합합니다.

세번째, 한개 이상의 정점에서의 최단거리를 모두 구하고 싶을 때 플로이드와샬을 사용합니다.



###### Q. (지현) 방금 말한 각 알고리즘의 시간복잡도를 알고있나요?

A. 시간복잡도를 표현하기 위해 먼저 간선의 개수를 V라고 정의하겠습니다.

첫번째, 다익스트라의 경우 일반 큐를 이용하면 O(V^2)의 시간복잡도를 나타내며, 최소 힙을 사용하면 O(Vlog⁡V)입니다.

두번째, 벨만포드는 *V*−1번 인접한 모든 간선들을 검사하는 과정을 거치기 때문에 시간 복잡도는 *O*(V^2)입니다.

세번째, 플로이드와샬은 3중 For문을 이용하여 O(V^3)의 시간복잡도를 나타냅니다.



###### Q. (소영) 자바 sort 라이브러리의 소팅 알고리즘은 무엇인지 아세요?

A. Arrays.sort()의 경우 dual pivot quicksort 알고리즘을 사용하고, Collections.sort() 의 경우 insertion sort 와 merge sort를 합친 time sort 알고리즘을 사용합니다.



###### Q. (소영) 머지소트 작동 과정을 설명하실 수 있나요?

A.  먼저 리스트를 두 개의 균등한 부분 집합으로 나누고 각 부분 집합을 정렬합니다. 다음 각 부분 집합들을 정렬하여 다시 정렬된 형태로 합쳐 정렬을 완성합니다.



###### Q. (소영) 퀵소트 작동 과정을 설명하실 수 있나요?

A.  먼저 리스트 안에서 한 요소를 선택합니다. 여기서 선택된 요소를 pivot이라고 칭합니다. 피벗을 기준으로 작은 요소는 왼쪽으로 큰 요소는 오른쪽으로 옮깁니다. 좌우로 이분화된 리스트를 재귀적으로 반복하여 정렬을 완성합니다.



###### Q. (소영) 퀵소트 시간 복잡도는 어떻게 되는지 아세요?

A.  평균과 최선의 경우엔 nlogn, 최악의 경우엔 n^2의 시간복잡도를 가지게 됩니다.



###### Q. (소영) 그렇다면 퀵소트의 최악의 경우 개선 방안을 설명해주세요

A. 첫번째로 피봇이 항상 편향되는 최악의 경우를 막기 위해 피봇값을 매번 랜덤한 위치로 잡는 방법이 있습니다. 두번째로 배열의 가장 첫 인덱스, 끝 인덱스, 중간 인덱스에 해당하는 값들을 정렬하고, 중간 값을 Pivot으로 사용하여 Quick Sort를 수행하는 방법이 있습니다.





