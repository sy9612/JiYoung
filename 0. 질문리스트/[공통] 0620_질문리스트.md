###### Q. (지영) 트리에 대해 설명해주세요.

A. 트리는 노드로 이루어진 자료구조입니다. 하나의 루트노드와 0개 이상의 자식노드로 구성되어 있습니다. 사이클이 존재할 수 없습니다.



###### Q. (지영) 트리의 특징을 말씀해주세요.

A. 트리는 그래프의 한 종류입니다. 트리에는 사이클이 존재하지 않으며 계층 모델입니다.

또한 루트에서 어떠한 노드로 가는 경로는 유일합니다. 즉 두개의 노드 사이에 단 1개의 경로만을 가집니다.

트리의 순회는 전위, 중위, 후위로 이루어집니다.

트리는 이진트리, 이진탐색트리, 균형트리와 이진힙 등이 존재합니다.



###### Q. (지영) 이진트리가 뭔가요?

A. 이진트리는 각 노드가 최대 두개의 자식을 갖는 트리를 말합니다.



###### Q. (지영) 이진탐색트리는 뭔가요?

A. 



###### Q. (지영) 이진탐색트리의 시간복잡도?

A. 





###### Q. (지홍) Java Collection Framework가 무엇인가요?

A. Collection은 요소로 알려진 객체 그룹입니다. 기본 인터페이스로는 set, list, map이 있습니다.

set은 중복 요소를 포함할 수 없는 모음입니다.

list는 정렬된 컬렉션으로 중복 요소를 포함 할 수 있습니다.

map은 키를 값에 매핑하여 중복 키를 포함할 수 없는 특징을 가지고 있습니다.



###### Q. (지홍) iterator에 대해서 설명해주세요.

A. literator는 반복자 인터페이스입니다. 컬렉션을 반복할 수 있는 메소드를 제공합니다. java collection은 iterator 메소드를 사용할 수 있습니다.

iterator는 반복하는 가운데 colleciton 요소를 제거할 수 있습니다.



###### Q. (지홍) HashMap의 작동 방법이 무엇인가요?

A. HashpMap은 키와 벨류를 쌍으로 지정합니다. 해싱을 통해 저장하여 사용합니다.



###### Q. (지홍) HashMap과 HashTable의 차이점은 무엇인가요?

A. HashMap은 널키와 널값을 허용하지만, HashTable은 널키나 널값을 허용하지 않습니다.

또한, HashMap은 동기화가 되지 않지만 HashTable은 동기화를 지원합니다.



###### Q. (지홍) ArrayList와 LinkedList의 차이점은 무엇인가요?

A. ArrayList는 인덱스 기반 데이터 구조입니다. 따라서 검색에 O(1)의 속도를 가지고 무작위로 액세스할 수 있습니다. 그러나 LinkedList는 이전과 다음 요소로 연결되는 형태로 검색에 실행 시간이 오래 걸립니다. 삽입, 삭제에는 ArrayList보다 빠르다는 장점을 가지고 있습니다.



###### Q. (지홍) HashSet과 TreeSet의 차이점이 무엇인가요?

A. HashSet은 해시테이블을 이용해 구현하므로 요소들이 정렬되지 않습니다. 따라서, 삽입, 삭제, 검색 등은 O(1)의 시간복잡도를 가집니다.

TreeSet은 트리 구조를 사용하여 구현하므로 요소가 정렬됩니다. 따라서 삽입, 삭제, 검색에 O(logN)의 시간복잡도를 가집니다.



###### Q. (지홍) Stack과 Queue 차이점과 사용예시를 알려주세요.

A. Stack은 선입후출 구조입니다. 입력과 출력이 한 곳에서 나옵니다. 대표적으로는 뒤로가기 구현 시 사용합니다.

Queue는 선입선출 구조로, 입력과 출력이 다른 것입니다. 대표적으로 Cache, 은행 업무 등이 있습니다.



###### Q. (지홍) Vector와 List의 차이점에 대해서 알려주세요.

A. Vector는 요소들이 인접해 있어 임의 접근이 가능하지만, List는 노드가 흩어져 있으므로 양방향으로만 이동이 가능합니다. 따라서, list는 임의 위치를 상수시간 내에 엑세스 할 수 없습니다.



###### Q. (지홍) 해시테이블이 무엇인가요?

A. 해시 테이블은 키와 벨류를 저장한 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용합니다.

해시의 idnex 값에 충돌이 발생한 경우, 충돌된 index 값에 대해 연결된 데이터들을 조회하여 원하는 값을 조회하므로 O(N)까지 시간복잡도가 증가할 수 있습니다.