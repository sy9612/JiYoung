###### Q. (지홍) 프로그램과 프로세스의 차이점에 대해 설명해주세요.

A. 프로세스와 프로그램의 가장 큰 차이점은 메모리 적재 유무입니다. 프로그램은 메모리에 올라가 있지 않은 정적인 상태이고, 프로세스는 메모리에 올라가 있는 동적인 상태를 의미합니다.



###### Q. (지홍) 프로세스에 대해서 좀 더 자세히 설명해주세요.

A. 네, 프로세스는 운영체제로부터 자원을 할당 받는 **작업의 단위**입니다.

프로세스의 특징으로는 각각 독립된 메모리 영역을 할당받아, 프로세스끼리 자원 공유가 불가능합니다. 이로 인해 하나의 프로세스가 실행 오류가 발생하여도 다른 프로세스에 영향을 받지 않습니다.



###### Q. (지홍) 스레드는 무엇인가요?

A. 스레드는 하나의 프로그램 내에서 여러 개의 실행 흐름을 가지는 **최소 작업 단위**입니다.

스레드의 특징으로는 자원을 공유한다는 것입니다. 따라서, 하나의 스레드가 오류가 발생하면 프로세스 내 다른 스레드도 모두 강제로 종료합니다.



###### Q. (지영) 프로세스와 스레드의 차이점에 대해서 설명해주세요.

A. 프로세스는 실행중인 프로그램을 의미합니다. 스레드는 한 프로세스 내에서 실행되는 하나의 작업단위입니다.

프로세스는 운영체제로부터 자원을 직접 할당받고 각각 독립적인 메모리 영역을 가집니다. 스레드는 이러한 프로세스에서 스택영역을 제외한 나머지 자원들을 공유합니다. 이로 인해 하나의 프로세스에서 병렬적으로 여러 개의 작업을 처리할 수 있습니다.



###### Q. (지홍) 프로세스 메모리 구조에 대해 설명해주세요.

A. 프로세스의 메모리는 크게 4가지의 영역으로 나누어져 있습니다.

Code 영역은 정적 할당 영역으로, 프로그램 코드가 저장되는 영역입니다.

Data 영역은 전역변수를 저장하는 공간입니다. 프로그램이 시작될 때 할당되어 프로그램이 종료될 때 소멸됩니다.

Stack 영역은 지역변수를 저장하는 공간입니다. 함수 호출 시 할당되고 반환 시 소멸됩니다.

Heap 영역은 메모리 주소 값에 의해 참조되고 사용되는 영역입니다.



###### Q. (지홍) 멀티스레드가 무엇인가요?

A. 멀티스레드는 하나의 프로세스가 여러 스레드를 사용하는 것입니다.

이러한 멀티 스레드를 사용하면 공유하고 있는 메모리만큼 자원을 아낄 수 있습니다. 그러나 동기화 문제가 발생할 수 있습니다.



###### Q. (지홍) 문맥 교환이 무엇인가요?

A. 문맥교환은 CPU의 코어수보다 더 많은 스레드가 실행될 때, 정해진 시간 동안 작업을 번갈아가며 수행하는 것입니다. 문맥 교환에 시간이 걸리면 멀티 쓰레딩 효율이 저하된다는 단점이 있습니다.



###### Q. (지홍) 동시성과 병렬성의 차이점이 무엇인가요?

A. 네, 동시성은 여러 스레드가 번걸아가면서 실행되는 것이고, 병렬성은 각 코어들이 동시에 실행되는 것입니다.



###### Q. (지홍) VM과 컨테이너의 차이점이 무엇인가요?

A. VM은 게스트 운영 체제가 존재하여 하드웨어의 자원을 논리적으로 격리한다는 것입니다. 컨테이너는 운영체계 수준의 격리 기술로, 애플리케이션 실행 파일에 필요한 요소들을 묶어서 패키지하여 배포하는 것입니다.

이러한 컨테이너의 성질로 인해 실행 환경을 독립적으로 운용할 수 있지만, VM보다 더 가볍다는 장점이 있습니다.



###### Q. (지현): 가상메모리의 개념과 장점을 설명해주세요.

A. 먼저 가상메모리를 사용하게 된 배경을 설명드리겠습니다. 프로그램은 RAM이라고 불리는 메인메모리에 적재되어 실행됩니다. 그러나 실행할 프로그램의 크기나 개수에 비해 메인메모리의 용량은 한계가 있기 때문에 이를 보완하기 위해 가상메모리를 사용합니다. 

가상메모리는 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식입니다. 

가상 메모리를 사용함으로써 사용자 프로그램이 메인메모리보다 커져도 실행 가능하기 때문에 메모리 크기의 제약으로부터 자유로워집니다. 또한 더 많은 프로그램을 동시에 수행 가능하기 때문에 병행성과 CPU 이용률이 증가합니다.



###### Q. (지현): 메모리 단편화가 무엇인지 설명해주세요.

A. 메모리 단편화란 메모리의 공간이 작은 조각으로 나뉘어져 수치상으로는 사용가능한 메모리가 충분히 존재하지만, 실제로 할당 및 사용이 불가능한 현상을 말합니다. 크게 내부 단편화, 외부 단편화로 구분합니다.

첫번째, 내부단편화는 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 남은 메모리 공간을 사용하지 않아 낭비 되는 현상입니다.

두번째, 외부단편화는 메모리가 할당 및 해제 작업의 반복으로 여유 공간이 여러 조각으로 나뉘어 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 현상입니다. 

이러한 메모리 단편화는 각각 세그먼테이션, 페이징을 통해 해결 가능합니다.



###### Q. (지현): 메모리 단편화 해결방법으로 언급한 세그먼테이션과 페이징에 대해 자세하게 설명해주세요.

A. 첫번째 세그먼테이션부터 설명드리겠습니다. 세그먼테이션은 프로세스를 논리적인 내용 단위인 세그먼트로 분할하고 메모리를 할당하여 관리하는 기법입니다. 프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부 단편화를 해결하지만 프로세스를 메모리에 적재시키고 해제함을 반복함으로써 외부 단편화가 발생합니다.

두번째, 페이징은 물리적인 크기 단위인 페이지와 프레임으로 프로세스와 메모리를 분할하여 가상 주소 공간과 물리 주소 공간을 매칭하여 관리하는 기법입니다. 연속적인 물리 메모리가 아니더라도 프로세스가 필요한 만큼의 프레임을 사용할 수 있어 외부 단편화를 해결하지만 고정된 크기의 프레임을 할당하기 때문에 내부 단편화가 발생합니다.



###### Q. (지현): 페이지 폴트에 대해 설명해주세요.

A. CPU는 프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회하는데, 실제 물리 메모리에 해당 페이지가 적재되어있지 않아 접근할 수 없을 때 페이지 폴트가 발생합니다. 

페이지 폴트가 발생하면 운영체제는 하드디스크에서 페이지를 가져와 물리메모리에 적재하고, 이를 가상메모리와 매핑하여 페이지 테이블에 기록합니다. 필요한 페이지가 물리메모리에 적재되었기 때문에 프로세스 실행이 다시 가능해집니다.

이 과정에서 I/O에 의한 속도 저하가 발생하고, 페이지 적재 과정을 기다리는 시간 때문에 프로세스 실행 시간이 길어지게 됩니다.

**Q. (지영): CPU 스케쥴링에 대해 설명해주세요.**

A. 메모리에 올라온 프로세스들 중 어떤 프로세스를 먼저 처리할지 순서를 정하는 작업을 의미합니다. 즉, Ready Queue에 있는 프로세스들 중에 누구에게 CPU를 할당해 줄 것인지 정하는것이 CPU 스케쥴링입니다.



**Q. (지영): CPU 스케쥴러는 언제 동작하나요?**

A. CPU 스케쥴러는 4가지 상황에서 동작합니다.

첫번째로 한 프로세스가 실행상태에서 대기상태로 전환될 때 동작합니다.

두번째로 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때 동작합니다.

세번째로 프로세스가 대기상태에서 준비완료 상태로 전환될 때 동작합니다.

네번째로 프로세스가 종료될 때 동작합니다.



**Q. (지영): 왜 CPU 스케쥴링이 필요한가요?**

A. CPU는 한번에 하나의 프로세스만 실행시킬 수 있습니다. 따라서 특정 프로세스가 I/O 요청에 의해 대기해야할 경우 CPU는 아무일도 안하고 있게 됩니다.

다중 프로그래밍에서는 이러한 시간을 생산적으로 활용하고자 CPU를 그 프로세스로부터 회수해 다른 프로세스에 할당합니다.

그 외 여러가지 예시들도 있겠지만 CPU 스케줄링이 필요한 이유는 하나로 통일되는데, 바로 CPU 이용률 극대화 입니다.

크게 선점 스케쥴링과 비선점 스케쥴링이 있습니다.



**Q. (지영): 선점 스케쥴링 방법 중 3가지를 골라 설명해주세요**

A. 선점 스케쥴링은 프로세스가 실행상태에서 준비완료상태로 전환될 때와 프로세스가 대기상태에서 준비완료상태로 전환될 때 수행됩니다.

선점 스케쥴링에는 Shortest Remaining Time 스케쥴링, Round-Roibin 스케쥴링, Multilevel Queue 스케쥴링이 있습니다.

먼저 SRT는 처리시간이 짧은 프로세스 순서대로 처리하는 방식입니다. 이런 프로세스가 Ready 큐에 들어오면 그 프로세스가 바로 선점됩니다. 평균 대기시간 측면에서 최적인 방법입니다.

RR은 각 프로세스에게 CPU 시간을 할당해주고 선입선출에 의해 실행됩니다. 할당되는 시간이 너무 크면 선입선출과 바를 바가 없고 할당되는 시간이 너무 작으면 오버헤드가 커집니다.

Multilevel Queue의 경우는 Ready 큐를 여러개 사용하는 기법입니다. 각각의 레디 큐는 자신의 스케쥴링 알고리즘을 수행하고, 큐와 큐 상이에도 우선순위를 부여합니다.




**Q. (소영): 세마포어와 뮤텍스에 대해 설명해주세요**

프로세스나 스레드에서 통신 시 공유 메모리를 쓴느 경우 하나의 자원에 두 개 이상의 프로세스나 스레드가 접근하는 경우에 문제가 발생합니다. 이를 제어하기 위해 스레드는 뮤텍스를 사용하고 프로세스에서는 세마포어를 사용합니다.

뮤텍스는 상호배제라고도 하며 임계영역을 가진 스레드의 러닝타임이 겹치지 않도록 각각 단독으로 실행하게 하는 기술입니다.

세마포어는 사용중인 리소스를 잠그는데 사용되는 보호된 변수 또는 추상 데이터 유형입니다. 

**Q. (소영): 세마포어와 뮤텍스의 차이에 대해 설명해주세요.**

A. 첫번째로 세마포어는 공유 자원에 세마포어의 변수만큼의 프로세스(또는 쓰레드)가 접근할 수 있습니다. 반면에 뮤텍스는 오직 1개만의 프로세스(또는 쓰레드)만 접근할 수 있습니다.

두번째로 세마포어는 현재 수행중인 프로세스가 아닌 다른 프로세스가  해제할 수 있습니다. 하지만 뮤텍스는 락(lock)을 획득한 프로세스가 반드시 그 락을 해제해야 합니다.



**Q. (소영): 데드락은 무엇인가요?**

A. 데드락은 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에, 다음 단계로 진행하지 못하고 무한히 기다리게 되는 상태를 말합니다. 교착상태라고도 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생합니다.



**Q. (소영): 그렇다면 데드락이 발생하는 이유는 무엇인가요?**

A. 데드락은 4가지 조건이 동시에 성립될 때 발생합니다.

첫째 상호배제로 한번에 한 프로세스만 공유자원을 사용할 수 있습니다. 다른 프로세스는 공유자원에 대한 접근이 제한되어 요청한 자원이 해제될때까지 대기해야 합니다.

둘째는 점유대기로 최소한 하나의 자원을 보유하고 있으면서 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 있어야 합니다.

셋째는 비선점으로 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 합니다.

마지막으로 환형대기는 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야합니다.



**Q. (소영): 데드락을 해결하는 방법은 무엇인가요?**

A. 데드락을 해결하는 방법은 예방, 회피, 탐지 및 회복 방법이 있습니다.

먼저 예방방법은 데드락 발생 조건 4가지 중 하나를 제거하여 해결하는 방법입니다.

둘째로 회피방법은 교착상태가 발생하면 적절히 피해나가는 방법입니다. 회피기법에선 주로 은행원 알고리즘을 사용합니다.

마지막으로 탐지 및 회복 방법은 교착 상태가 되도록 허용한 다음에 회복시키는 방법입니다.

