## [운영체제] 가상 메모리

  

### 가상메모리 (Virtual Memory)

프로그램은 RAM이라고 불리는 메인메모리(주기억장치)에 적재되어야 실행된다. 실행될 프로그램의 크기가 주기억장치보다 크거나 프로그램을 여러개 실행할 경우에는 주기억장치의 공간 부족으로인해 프로그램이 제대로 실행되지 못할 수 있다. 

이러한 RAM의 부족한 용량을 보완하기 위해, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식을 사용한다. CPU는 우선 가상 주소를 먼저 참조하고, 가상 메모리 주소에 해당하는 실제 물리 메모리 주소를 참조하게 된다. 이 때 가상 주소값을 물리 주소값으로 변환해주는 하드웨어 장치인 MMU(Memory Management Unit)를 사용함으로써 빠른 주소 변환을 지원한다.



----



### 메모리 단편화 (Memory Fragmentation)

RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 수치상으로는 사용가능한 메모리가 충분히 존재하지만, 할당/사용이 불가능한 현상을 말한다. 



**내부단편화**

메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 남은 메모리 공간을 사용하지 않아 낭비 되는 현상



**외부단편화**

메모리가 할당 및 해제 작업의 반복으로 여유 공간이 여러 조각으로 나뉘어 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황



-----



### 메모리 단편화 해결방법



**세그먼테이션 (Segmentation)**

프로세스를 논리적인 내용 단위인 세그먼트(segment)로 분할하고 메모리를 할당하여 관리하는 기법이다. 세그먼트 테이블(Segment Table)로 CPU에서 할당한 논리 주소에 해당하는 물리 주소의 위치를 기록한다.

세그먼트는 크기가 고정되어 있지 않고 가변적이기 때문에 메모리를 미리 분할하는 것이 아니라 메모리를 사용할 시점에 동적으로 할당한다. 프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부 단편화를 해결한다. 하지만 프로세스를 메모리에 적재시키고 해제함을 반복함으로써 외부 단편화가 발생한다.



**페이징 (Paging)**

프로세스를 물리적인 크기 단위인 페이지(Page)로 나누고, 물리 메모리는 프레임(Frame)으로 나누어 페이지 테이블을 기반으로 가상 주소 공간과 이에 매칭되는 물리 주소 공간을 관리하는 기법이다.

프레임과 페이지는 메모리를 일정한 크기의 공간으로 나누어 관리하는 단위이며, 프레임과 페이지의 크기는 같다. 페이지가 하나의 프레임을 할당 받으면, 물리 메모리에 위치하게 된다. 프레임을 할당 받지 못한 페이지들은 외부 저장장치(하드디스크)에 저장되며, 이때도 프레임과 같은 크기 단위로 관리된다.

페이지 테이블은 프로세스의 페이지 정보를 저장하고 있으며, 하나의 프로세스는 하나의 페이지 테이블을 가진다. 페이지 테이블의 인덱스는 페이지 번호이며, 해당 페이지에 할당된 물리 메모리(프레임)의 시작 주소를 저장한다. 이 시작 주소와 페이지 주소를 결합하여 물리 메모리 주소를 알 수 있다.

연속적인 물리 메모리가 아니더라도 프로세스가 필요한 만큼의 프레임을 사용할 수 있다. 연속적이지 않은 메모리 공간을 활용하기 때문에 외부 단편화를 해결한다. 하지만 고정된 크기의 프레임을 할당하기 때문에 내부 단편화가 발생한다. 페이지 단위를 작게하면 내부 단편화 문제도 해결할 수 있지만 대신 페이지 매핑 과정이 많아지므로 오히려 효율이 떨어질 수 있다.



-----



### 요구 페이징 (Demand Paging)

프로세스를 구성하는 페이지 전체를 메모리에 적재하는 것이 아니라, 특정 페이지에 대해 CPU 의 요청이 들어온 이후에 해당 페이지를 메모리에 적재하는 기술이다. 프로세스 내에서 한 번도 접근되지 않은 페이지는 절대로 메모리에 로드되지 않는다. 프로세스 내의 개별 페이지들은 페이저(Pager)에 의해 관리된다. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 로드하기 때문에 사용되지 않을 페이지를 가져오는 시간 낭비와 메모리 낭비를 줄일 수 있다.



**페이지 부재 (Page Fault)**

CPU는 프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회하는데, 실제 물리 메모리에 존재하지 않는 페이지에 접근하려고 할 때 페이지 폴트가 발생한다. 페이지 폴트 인터럽트가 일어나면 운영체제가 가상메모리를 통해서 해당 페이지를 물리 메모리에 올린다. 페이지폴트가 발생하면 I/O에 의한 속도의 저하가 발생하게 되고, 프로세스 실행 시간이 길어지게 된다. 페이지 폴트를 방지하려면 향후 실행/참조될 페이지를 미리 물리 메모리에 올리면 되는데, 어떤 페이지가 참조될 지 미리 예측하는 것은 쉽지 않다.



**페이지 교체**

페이지 부재 발생시 메모리에 해당 페이지를 적재해야 하는데, 물리메모리가 모두 사용중이라 비어있는 프레임이 없으면 페이지 교체가 이뤄져야한다. 페이지 교체 알고리즘을 통해 희생 프레임을 골라서 하드 디스크에 기록 후 프레임을 비우고, 필요한 페이지를 물리 메모리에 로드한다. 



**요구페이징 수행 단계**

![demand paging](https://t1.daumcdn.net/cfile/tistory/2513314A55FE533722)

1. CPU가 특정 페이지에 접근하기 위해 페이지 테이블의 Valid bit를 확인하여 메모리에 페이지가 존재하는지 확인한다.
2. 실제 물리 메모리에 존재하지 않는 페이지에 접근하려고 하면 MMU가 페이지 부재 트랩(page fault trap)을 발생시켜 운영체제에 알린다. 운영체제는 프로세스를 wait 상태로 변경한다. CPU의 제어권이 커널 모드(kernal mode)로 전환되어 운영 체제의 페이지 부재 처리 루틴(page fault handler)이 호출된다. 
3. 하드디스크에서 페이지를 찾아 가져온다.
4. 물리 메모리의 비어있는 프레임(Free Frame)에 페이지를 로드한다. 비어 있는 프레임이 없다면 페이지 교체를 진행한다.
5. 페이지 테이블을 최신화 한다.
6. 프로세스를 다시 ready -> running하여 작업을 진행한다.



**스레싱 (Thrashing)**

![Thrashing](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FO809c%2FbtqNpGuMlfE%2FKRhDXJdt1zdczV9FeuHFq0%2Fimg.png)

만약 프로세스를 실행하기 위한 충분한 프레임을 확보하지 못하면 페이지 폴트가 일어난다. 페이지 교체가 필요하지만 이미 모든 페이지가 사용중이었기 때문에 교체되는 순간 다시 페이지 폴트를 발생시키게 된다. 이런 과정이 반복되면 페이지를 교체하는 시간이 실제로 페이지가 실행되는 시간보다 길어지게 되는데, 이를 스레싱(Thrashing)이라 한다. 프로그램을 수행하지 못한 채 페이지 폴트와 페이지 교체만 반복적으로 수행된다.

스레싱은 메모리의 크기가 일정할 경우 멀티프로그램의 수와 밀접한 관계가 있다. 멀티 프로그래밍의 정도(동시에 실행하는 프로그램 수)가 증가하면 CPU 이용률이 계속 증가하다가 CPU 이용률이 최대값에 도달하고 메모리가 꽉 차면 CPU가 작업하는 시간보다 페이지 교체 작업이 빈번해져 CPU가 작업할 수 없는 상태에 이른다. 이 시점을 Thrashing Point라고 한다.

스레싱 현상을 방지하기 위해 각 프로세스가 필요로 하는 최소한의 프레임 갯수를 보장해야 한다.



-----

### 페이지 교체 알고리즘



**FIFO**

메모리 내에서 가장 오래된 페이지를 교체하는 알고리즘이다. 

이 알고리즘을 수행하기 위해서 각 페이지가 올라온 시간을 페이지에 기록하거나, 페이지가 올라온 순서를 큐(Queue)에 저장하는 방식 등을 사용할 수 있다. 활발하게 사용중인 페이지를 계속해서 교체한다면  페이지 폴트가 증가하고 실행속도가 떨어질 위험이 있다. 이를 Belady's anomaly라고 한다.



**OPT (Optimal Page Replacement)**

앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 알고리즘이다.

가장 오랫동안 사용되지 않을 페이지를 알고 교체하기 때문에 모든 페이지 교체 알고리즘 중 페이지 폴트가 가장 적다는 것이 보장되며 Belady's anomaly도 일어나지 않는다. 프로세스가 앞으로 사용할 페이지를 미리 알아야 한다는 전제조건이 필요한데, 실제 활용에서는 이 전제조건을 충족할 수 없기 때문에 구현이 불가능하다. (프로세스 스케줄링의 SJF와 비슷하다.) 실제 구현 목적보다 다른 알고리즘과 비교 연구 목적을 위해 주로 사용된다.



**LRU (Least Recently Used)**

가장 오래 사용되지 않은 페이지를 교체하는 알고리즘이다. 

OPT 알고리즘은 페이지가 사용될 시간을 미리 알고 있어야 한다. 미리 아는 것이 불가능하기 때문에, 대신 과거의 데이터를 바탕으로 페이지가 사용될 시간을 예측하는 방식을 사용한다. 즉, 최근에 사용한 페이지 중에서 가장 오래된 페이지를 victim으로 선택한다. LRU 알고리즘은 최적 알고리즘보다 페이지 교체 횟수가 높지만 FIFO 알고리즘 보다 효율적이다. 



**LFU (Least Frequently Used)**

계수-기반(Counting-Based) 페이지 교체  기법 중 하나로, 참조 횟수가 가장 적은 페이지를 교체하는 알고리즘이다. 

만약 교체 대상인 페이지가 여러 개 일 경우, LRU 알고리즘을 따라 가장 오래 사용되지 않은 페이지로 교체한다. LFU 알고리즘은 초기에 한 페이지를 집중적으로 참조하다가 이후 다시 참조하지 않는 경우 문제가 될 수 있다. 앞으로 사용하지 않아도 초기에 사용된 참조횟수가 높아 메모리에 계속 남아있기 때문이다.



-----



가상메모리 관리(1): https://velog.io/@gndan4/OS-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC

가상메모리 관리(2): https://empty-cloud.tistory.com/73?category=820283

메모리 단편화: https://junghyun100.github.io/%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%8B%A8%ED%8E%B8%ED%99%94/

세그먼테이션: https://copycode.tistory.com/108?category=740133

페이징(1): https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%A7%95

페이징(2): https://copycode.tistory.com/98?category=740133

요구페이징/페이지폴트(1): https://preamtree.tistory.com/21

요구페이징/페이지폴트(2): https://developerhenrycho.tistory.com/23

스레싱: https://4legs-study.tistory.com/55

페이지 교체 알고리즘: https://medium.com/pocs/%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-page-replacement-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-650d58ae266b
