# OS

참고: https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4

### 프로세스와 스레드

###### 프로그램

> 파일이 저장 장치에 저장되어 있지만 메모리에는 올라가 있지 않은 정적인 상태

###### 프로세스

![img](../image/103.png)

- 실행중인 프로그램

- 운영체제로부터 자원을 할당 받은 작업의 단위

  > 프로세스끼리 **자원 공유 불가능**
  >
  > 각각 독립된 메모리 영역을 할당

  - 한 프로세스를 실행하다 오류가 발생하여 프로세스가 강제 종료되어도 다른 프로세스에 영향X

- 사용 중인 파일, 데이터, 프로세서의 상태, 메모리 영역 주소 공간, 스레드 정보, 전역 데이터가 저장된 메모리 부분 등 **수많은 자원**을 포함하는 개념

- 메모리에 적재되어 실행되고 있는 프로그램

- 한 프로그램에 여러 프로세스가 동시에 존재할 수 있음

  

###### 스레드

- 하나의 프로그램 내에서 여러 개의 **실행 흐름**을 두기 위한 모델

  - CPU 입장에서 최소 작업 단위 (흐름의 단위)

- 독립적인 일의 단위

- 병렬적으로 여러 개의 작업을 처리

- **자원(메모리) 공유 가능**

  ![img](../image/104.png)

  - 프로세스가 할당 받은 메모리 영역 내 **Stack** 형식으로 할당된 메모리 영역은 따로 할당
  - 나머지 Code/Data/Heap 형식으로 할당된 메모리 영역 공유
  - 스레드1이 오류가 발생하면 같은 프로세스 내 다른 스레드 모두 강제 종료



### 프로세스 메모리 구조

![img](../image/998E6C3E5C9652C21F)

###### Code(text) 영역

- 정적 할당 영역
- 실행할 프로그램 코드 저장
- CPU가 해당 영역에서 명령어를 하나씩 가져와 처리

###### Data 영역

- 정적 할당 영역
- 전역변수와 정적변수 저장
- 프로그램이 시작될 때 할당되어 프로그램 종료 시 소멸

- ###### BSS(Block Stated Symbol)

  > 초기화되지 않은 전역변수 저장

- 초기화된 전역변수는 Data 영역에 저장되어 비휘발성 메모리인 ROM에 저장

  > 비용이 많이 들어 RAM에 저장될 것과 ROM에 저장될 것을 구분하기 위해 영역을 구분하여 사용

###### Stack 영역

- 동적 할당 영역
- 지역변수, 매개변수, 리턴 값
- 잠시 사용되었다가 사라지는 데이터 저장 영역
- 함수 호출 시 할당되고 반환 시 소멸
- 로드 시(컴파일 타임) 크기 결정
- 데이터를 높은 주소에서 낮은 주소로 쌓아 올림

###### Heap 영역

- 동적 데이터 영역

- 메모리 주소 값에 의해 참조되고 사용되는 영역

- 프로그램 동작 시(런타임)에 크기가 결정

  ex) Stack에서 Pointer가 가리키는 heap 영역의 임의의 공간으로부터 원하는 크기만큼 할당

- 데이터를 낮은 주소에서 높은 주소로 쌓아 올림



###### > Code + Data + Stack: 컴파일 시 크기를 계산하여 메모리 영역 결정



### 멀티태스킹, 멀티 스레드

###### 멀티태스킹

> 하나의 운영 체제 안에서 여러 프로세스가 실행되는 것
>
> 여러 개의 CPU를 사용하여 여러 프로세스를 동시에 수행

###### 멀티스레드

> 하나의 프로세스가 여러 작업을 여러 스레드를 사용하여 동시에 처리하는 것

- 장점

  1. **Context-Switching**할 때 공유하고 있는 메모리만큼의 메모리 자원을 아낄 수 있음

     > ###### 문맥 교환(Context-Switching)
     >
     > 현재까지의 작업 상태나 다음 작업에 필요한 각종 데이터를 저장하고 읽어오는 작업
     >
     > - CPU의 코어수보다 더 많은 스레드 실행 ▶ 각 코어가 정해진 시간 동안 여러 작업을 번갈아가며 수행
     > - 문맥 교환에 걸리는 시간이 커지면 멀티 쓰레딩 효율 저하
     > - 많은 양의 단순한 계산 -> 싱글 스레드 동작이 효율

  2. 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유 -> 통신 부담이 적어 응답시간이 빠름

  3. 자신이 속한 프로세스의 메모리 공유 -> 시스템 자원 낭비가 적음

- 단점

  1. 스레드 하나가 프로세스 내 자원을 망치면 모든 프로세스 종료
  2. **동기화 문제**(Synchronization Issue)
     - 어떤 순서로 실행될 것인지 순서를 알 수 없음
     - 여러 스레드가 함께 전역 변수를 사용할 경우 발생하는 충돌

###### 자바 싱크로나이즈, Stream

- https://tourspace.tistory.com/54?category=788398



### 동시성(Concurrency)과 병렬성(Parallelism)

https://beststar-1.tistory.com/24?category=976609

###### 동시성

싱글 코어에서 멀티스레드를 동작시키기 위한 방식

멀티 태스킹을 위해 **여러 개의 스레드가 번갈아가면서 실행**되는 성질

###### 병렬성

멀티 코어에서 멀티 스레드를 동작시키는 방식

**한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질**

▶ Context Switching(문맥 교환)이 일어남



### 멀티스레드 환경에서 경쟁상태 회피

###### 경쟁상태

- 프로세스들끼리 하나의 자원을 갖기 위해 싸우는 것
- 회피 방법: **세마포어, 뮤텍스**

#### 뮤텍스

공유된 자원의 데이터를 **여러 스레드**가 접근한 것을 막는 것

- 상호 배제

- Critical Section을 가진 스레드의 Running Time이 서로 겹치지 않도록 단독으로 실행하는 기술

- 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 synchronized 또는 lock 사용

  **뮤텍스 객체를 두 스레드가 동시에 사용할 수 없음**

#### 세마포어

공유된 자원의 데이터를 **여러 프로세스**가 접근하는 것을 막는 것

- 공유 리소스에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근하여 사용
- 리소스 상태를 나타내는 카운터
  - 운영체제/커널에 지정된 저장자치 내의 값
  - 비교적 긴 시간을 확보하는 리소스에 대해 이용
  - 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동 조정/동기화
- 프로세스는 세마포어 값을 확인하고 변경할 수 있음
  - 사용 중이지 않는 자원 -> 프로세스가 즉시 자원 사용
  - 사용 중인 자원 -> 재시도까지 일정 시간을 기다려야 함
  - 세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안 그 값을 변경하여 다른 세마포어 사용자들이 기다려야 함
- 이진수 사용 (추가적인 값 사용 가능)



#### 뮤텍스와 세마포어 차이점

- 동기화 대상 개수

  | 뮤텍스 | 세마포어 |
  | ------ | -------- |
  | 1개    | 1개 이상 |

- 세마포어 -> 뮤텍스 O

  뮤텍스 -> 세마포어 X

  뮤텍스 = binary Semaphore 이므로

- 소유권

  | 뮤텍스                                                       | 세마포어                                             |
  | ------------------------------------------------------------ | ---------------------------------------------------- |
  | 소유 가능 -> 소유주 책임                                     | 소유할 수 없음                                       |
  | 뮤텍스는 두 개의 상태를 가지는 lock이므로 lock을 가질 수 있음 |                                                      |
  | 뮤텍스를 소유하는 스레드만 뮤텍스 해제 가능                  | 세마포어를 소유하지 않은 스레드가 세마포어 해제 가능 |

- 범위

  | 뮤텍스                         | 세마포어                     |
  | ------------------------------ | ---------------------------- |
  | 프로세스 범위                  | 시스템 범위                  |
  | 프로세스 종료 시 자동 Clean up | 파일 시스템 상의 파일로 존재 |

  



### 데드락

둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황

###### 발생 조건

- 상호 배제

  한 번에 프로세스 하나만 해당 자원을 사용

- 점유 대기

  자원을 최소한 하나 보유, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스 존재

- 비선점

  이미 할당된 자원을 강제로 빼사을 수 없음

- 순환대기

  대기 프로세스의 집합이 순환 형태로 자원을 대기

###### 해결법

- 예방
  - 상호배제 방지: 여러 프로세스가 한 번에 공유 자원을 사용할 수 있게 함
  - 점유대기 방지: 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업 보류, 나중에 또다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 함
  - 비선점 방지: 우선순위가 높은 프로세스 자원 선점
  - 순환 대기 방지: 자원을 순환 형태로 대기하지 않도록 일정한 한쪽 방향으로만 자원 요구
- 회피
- 탐지





### 가상 메모리

- 프로그램의 실제 메모리 주소가 아닌 가상 메모리 주소 방식

- RAM보다 더 큰 메모리 영역을 제공하는 방법 -> 디스크 공간을 메모리처럼 활용

