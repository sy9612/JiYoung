## [DB] SQL 심화

-----

#### Query 문법 순서 & 실행 순서

**문법 작성 순서**

1. SELECT (DISTINCT)
2. FROM
3. JOIN (ON)
4. WHERE
5. GROUP BY
6. HAVING
7. ORDER BY

**실행 작동 순서**

1. FROM/JOIN
   데이터셋의 총량을 결정하기 위해 먼저 실행한다.
   여기에는 서브쿼리도 함께 포함되어 임시적인 테이블이 생성될 수 있다.
2. WHERE
   데이터셋을 형성하게 되면 WHERE의 조건이 개별 행에 적용이 되어 충족하지 않으면 제거한다.
3. GROUP BY
   WHERE의 조건 적용 후 나머지 행은 GROUP BY절에 지정된 열의 공통 값을 기준으로 그룹화한다. 
4. HAVING
   GROUP BY 절이 쿼리에 있을 경우 HAVING 절의 제약조건이 각 행에 적용되어 충족하지 않으면 제거한다.
5. SELECT
   SELECT절을 실행한다.
6. DISTINCT
   표현된 행에서 중복된 행은 삭제한다.
7. ORDER BY
   특정 규칙에 따라 오름차순/내림차순으로 정렬한다.

------

#### 부속질의 (Subquery)

하나의 SQL문 안에 다른 SQL 문이 중첩된 질의. 다른 테이블에서 가져온 데이터로 현재 테이블에 있는 정보를 찾거나 가공할 때 사용한다. JOIN은 테이블1과 테이블2을 합쳐서 연산하여 필요 데이터를 추출하지만, 부속질의는 테이블1 정보를 가지고 테이블2에서 확인하는 기법이기 때문에 데이터가 대량일 때 부속질의의 성능이 좋다. 



![부속질의](https://t1.daumcdn.net/cfile/tistory/993E5A3F5A7C52D939)



**스칼라 부속질의(SELECT 부속질의, Scalar Subquery)**

부속질의의 결과 값을 단일 행, 단일 열의 스칼라 값으로 반환한다.

원칙적으로 스칼라 값이 들어갈 수 있는 모든 곳에 사용 가능하며, 일반적으로 SELECT문과 UPDATE SET 절에 사용된다.

![스칼라부속질의](https://t1.daumcdn.net/cfile/tistory/99950D4E5A7C55EE1D)



**인라인 뷰(FROM 부속질의, Inline View)**

테이블 이름 대신 인라인 뷰 부속질의를 사용하면 보통의 테이블과 같은 형태로 사용할 수 있으나, 가상의 테이블인 뷰 형태로 제공되기 때문에 유의해야 한다.

![인라인뷰](https://t1.daumcdn.net/cfile/tistory/9907ED375A7C578E2D)



**중첩질의(WHERE 부속질의,  Nested Subquery)**

주 질의에서 필요한 조건을 다른 테이블에서 가져오는 질의문. 부속질의 결과 반환되는 데이터는 다중 행, 다중 열이어도 상관없다.

![중첩질의](https://t1.daumcdn.net/cfile/tistory/99258F475A7C5A242D)

-----

#### JOIN

관계형 데이터베이스에서는 중복 데이터를 피하기 위해서 데이터를 쪼개 여러 테이블로 나눠서 저장한다. 이렇게 분리되어 저장된 데이터에서 원하는 결과를 다시 도출하기 위해서는 여러 테이블을 조합할 필요가 있다. 관계형 데이터베이스에서는 조인(JOIN) 연산자를 사용해 관련 있는 컬럼 기준으로 행을 합쳐주는 연산을 진행한다.

![조인](https://storage.googleapis.com/count-static/blog/img/THI3yjje8sP-p04ngl6Cu5q.png)

------

#### 병행제어&회복

**병행제어 (동시성 제어, Currency Control)**

여러개의 트랜잭션이 실행될 때 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않고 다른 트랜잭션에 영향을 주지 않도록 트랜잭션의 데이터 접근을 제어하는 것. 병행제어의 목적은 데이터 베이스의 공유와 시스템 활용도의 최대화, 데이터 베이스의 일관성 유지, 사용자에 대한 응답시간을 최소화하는데 있다.

**병행제어를 지원하지 않는 경우 문제점**

![문제점](https://t1.daumcdn.net/cfile/tistory/9968854D5A2F9E5E02)

* 오손 읽기 (Dirty Read)

  읽기 작업을 하는 T1이 쓰기 작업을 하는 T2가 작업하는 중에 중간 데이터를 읽기 때문에 생기는 문제.

  작업 중인 T2가 어떤 이유에서 작업을 철회(ROLLBACK)할 경우 T1은 무효화 된 데이터를 읽게 되고 잘못된 결과를 도출하는 현상

* 반복불가능 읽기 (Non-Repeatable Read)

  T1이 데이터를 읽고 T2가 데이터를 쓰고(UPDATE) T1이 다시 한 번 데이터를 읽을 때 생기는 문제.

  T1이 읽기 작업을 다시 한 번 반복하는 작업일 경우 이전의 결과와 다른 결과가 나오는 현상.

  오손 읽기와 달리 T2가 commit을 완료했기 때문에 틀린 데이터는 아니지만 T1 입장에서 같은 SQL문이 다른 결과를 도출한 것으로 보여질 수 았다.

* 유령데이터 읽기

  T1이 데이터를 읽고 T2가 데이터를 쓰고(삽입, INSERT) T1이 다시 한 번 데이터를 읽을 때 생기는 문제

  T1이 읽기 작업을 다시 한 번 반복할 경우 이전에 없던 데이터(유령데이터)가 나타나는 현상

  T2가 commit을 완료했기 때문에 틀린 데이터는 아니지만 T1이 예상한 결과와 다른 결과를 도출한 것으로 보여질 수 있다. 반복불가능 읽기와 비슷하지만 새로운 데이터가 삽입되었기 때문에 다르게 구분한다.

* 갱신 손실 (Lost Update)
  하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효화가 되어 생기는 문제.

  두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신(Update)할 때 발생. 데이터베이스에서 절대 발생하면 안되는 현상

* 모순성 (Inconsistency)
  다른 트랜잭션들이 해당 항목 값을 갱신하는 동안 한 트랜잭션이 두 개의 항목 값 중 어떤 것은 갱신되기 전의 값을 읽고 다른 것은 갱신된 후의 값을 읽게 되어 데이터의 불일치가 발생하는 상황

* 연쇄 복귀 (Cascading Rollback)
  두 트랜잭션이 동일한 데이터 내용을 접근할 때 발생

  한 트랜잭션이 데이터를 갱신한 다음 실패하여 Rollback 연산을 수행하는 과정에서 갱신과 Rollback 연산을 실행하고 있는 사이에 해당 데이터를 읽어서 사용할 때 발생할 수 있는 문제

**병행제어 기법**

1. 로킹 (Locking)

   트랜잭션이 어떤 데이터에 접근하고자 할 때 로킹을 수행한다. 로킹을 한 트랜잭션만이 로킹을 해제할 수 있으며, 로킹되어 있는 데이터에는 다른 트랜잭션이 접근할 수 없다. 트랜잭션은 로킹이 된 데이터에 대해서만 연산을 수행할 수 있으며 로킹의 단위에는 필드, 레코드, 파일, 데이터베이스 모두 로킹이 될 수 있다.

   로킹 단위가 크면 로킹 오버헤드 감소로 관리가 용이하지만, 동시성 수준이 낮아진다. 반대로 로킹 단위가 작으면 동시성 수준이 높아지지만 로킹 오버헤드 증가로 관리가 까다롭다.

   * 2단계 로킹 규약(Two-Phase Locking Protocol)

     Lock과 Unlock이 동시에 이루어지면 두 개의 트랜잭션이 동시에 실행될 때 데이터의 일관성이 보장되지 않으므로 Lock만 가능한 단계와 Unlock만 가능한 단계를 구분하며 직렬가능성을 보장한다. 하지만 교착상태가 발생할 수 있다.

     \- 확장단계 : 트랜잭션이 Lock만 할 수 있고 Unlock은 할 수 없음

     \- 축소단계 : 트랜잭션이 Unlock만 할 수 있고 Lock은 할 수 없음

2. 타임스탬프 (Time Stamp)

   데이터에 접근하는 시간을 미리 정하여 정해진 시간의 순서대로 데이터에 접근하며 수행함, 직렬가능성을 보장하며 시간을 나눠 사용하기 때문에교착상태가 발생하지 않음, 하지만 연쇄복귀를 초래할 수 있음.

3. 낙관적 병행제어 (Optimistic Concurrency Control)

   트랜잭션 수행 동안은 어떠한 검사도 하지 않고, 트랜잭션 종료 시에 일괄적으로 검사함, 트랜잭션 수행 동안 그 트랜잭션을 위해 유지되는 데이터 항복의 지역사본에 대해서만 갱신하며 트랜잭션 종료 시에 동시성을 위한 트랜잭션 직렬화가 검증되면 일시에 DB로 반영함

4. 다중 버전 병행제어 (Multi-version Concurrency Control)

   하나의 데이터 아이템에 대해 여러 버전의 값을 유지하며 조회성능을 최대한 유지하기 위한 기법, 트랜잭션 간의 충돌 문제는 대기가 아니라 복귀처리 함으로 연쇄복귀초래 발생 가능성이 있음



**회복 (Recovery)**

데이터베이스의 회복이란 트랜잭션들을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업.

**회복을 위한 복사본 저장 방법**

1. 덤프 (Dump)

   가장 기본적인 기법. 일정 주기로 원본의 데이터베이스의 모든 내용을 다른 저장장치에 복사하여 보관.

2. 로그 (Log)

   변경 이전의 데이터베이스를 기준으로 변경 연산이 발생할 때 마다 로그 파일을 작성하여 기록하고, 회복할 때 로그에 적힌 내용을 사용하여 복원.

**회복 기법**

1. 재실행 (Redo)
  데이터 베이스 내용 자체가 손상이 된 경우 가장 최근의 복제본을 적재시킨 뒤 이 복제본 이후에 일어난 변경만을 로그를 이용하여 재실행함으로써 데이터 베이스를 복원하는 것. 

2. 취소 (Undo) 
데이터베이스 내용 자체는 손상되지 않았지만 변경 중이거나 변경된 내용에 대한 신뢰성을 잃어버린 경우 로그를 이용하여 모든 변경들을 취소시킴으로써 원래의 데이터베이스 상태로 복원하는 것

-----

#### SQL 내장함수

[참고하세요](https://wickies.tistory.com/45)

------

**참고**

[쿼리실행순서](https://jaimemin.tistory.com/1475)

[부속질의](https://mangkyu.tistory.com/25)

[병행제어](https://kosaf04pyh.tistory.com/300)

[회복]()(https://kosaf04pyh.tistory.com/299)

[병행제어&회복(1)](https://goodmilktea.tistory.com/62)

[병행제어&회복(2)](https://mangkyu.tistory.com/30?category=761304)

