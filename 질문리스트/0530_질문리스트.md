# Q. 지영: 자바에 대해 설명해주세요.

A. 자바는 네트워크 상에서 동작하는 객체지향 프로그래밍 언어입니다. write once, run everywhere라는 자바의 슬로건에 맞게 운영체제와 상관없이 동작합니다.


**Q. 자바 코드 실행과정을 설명해주세요.**

A. 먼저 작성한 자바소스를 자바 컴파일러를 통해 자바 바이트코드로 컴파일합니다. 이후 컴파일된 바이트코드를 JVM 클래스 로더에게 전달합니다. 클래스 로더는 동적로딩을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역, 즉 JVM 메모리에 올립니다. 마지막으로 실행엔진이 JVM메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행합니다.

**Q. JVM의 구성요소를 아시나요?**

A. JVM은 Class Loader, Execution Engine, Garbage Collector, Runtime Data Area 4가지로 구성되어 있습니다.

Class Loader는 클래스 파일들을 엮어서 JVM 운영체제로부터 할당 받은 메모리 영역인 runtime data area 로 적재하는 역할을 합니다.

Execution Engine은 메모리에 적재된 클래스들을 기계어로 변경해 명령어 단위로 실행하는 역할을 합니다.

Garbage Collector는 heap 메모리 영역에 생성된 객체 들 중에 참조되지 않는 객체들을 탐색 후 제거하는 역할을 합니다. GC가 수행되는 동안에는 GC를 수행하는 쓰레드 이외의 다른 모든 쓰레드가 일시정지됩니다.

Runtime Data Area는 JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역입니다. 이 영역은 크게 Method, Heap, Stack, PC register, Native method stack으로 나눌 수 있습니다.

<img src="/Users/lsy/Library/Application Support/typora-user-images/image-20210529152347476.png" alt="image-20210529152347476" style="zoom:25%;" />

**Q. method, heap, stack, pc register, native method stack에 대해 설명해보세요**

A. 메소드 영역은 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보같은 필드 정보와 메소드의 이름, 리턴 타입, 파라미터, 접근 제어자 정보같은 메소드 정보, Type정보(Interface인지 class인지), Constant Pool(상수 풀 : 문자 상수, 타입, 필드, 객체 참조가 저장됨), static 변수, final class 변수등이 생성되는 영역입니다.

힙 영역은 new 키워드로 생성된 객체와 배열이 생성되는 영역이다. 메소드 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역이다.

스택영역은 지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값등이 생성되는 영역이다.

PC레지스터는 쓰레드가 생성될 때마다 생성되는 영역으로 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역입니다.

native method stack은 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역입니다.

**Q. 스레드란?**

A. 스레드는 프로세스 내에서 프로그램 명령을 실행하는 기본 단위입니다 (CPU 이용의 기본단위). 스레드는 스레드 id, 프로그램 카운터, 레지스터 집합, 스택으로 구성되어 있으며 같은 프로세스에 속한 다른 스레드와 운영체제 자원들을 공유합니다.

**Q. 멀티스레드와 싱글 스레드이 무엇인지, 장단점이 무엇인지 설명해보세요**

A.  하나의 프로세스에서 하나의 스레드를 실행하면 싱글 스레드이고, 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것을 멀티스레드라고 합니다.

싱글 스레드는 자원 접근에 대한 동기화를 신경 쓰지 않아도 되고, 문맥교환 작업을 요구하지 않습니다. 하지만 여러 개의 CPU를 활용하지 못한다는 단점을 가지고 있습니다.

멀티 스레드를 사용하면 새로운 프로세스를 생성하는 것보다 기존 프로세스에서 스레드를 생성하는 것이 빠르고, 프로세스 자원과 상태를 공유하여 효율적으로 운영할 수 있다는 장점을 가지고 있습니다. 하지만 하나의 스레드만 실행중일 때에는 실행시간이 오히려 지연될 수 있으며 멀티 스레딩을 위한 운영체제의 지원이 필요하고 스레드 스케쥴링을 신경써야 한다는 단점이 있습니다.

**Q. 스케줄링 방식에 대해 설명해보세요**

스케줄링은 우선 크게 선점과 비선점 방식으로 나뉩니다. 선점 방식이란 실행중인 프로세스가 강제적으로 실행권을 빼앗아 우선 순위가 높은 프로세스를 빠르게 처리하는 방식이고, 비선점 방식은 실행 중인 프로세스가 자신의 실행권을 자발적으로 내려놓을 때까지 다른 프로세스들이 대기 해야하는 방식입니다. 선점 스케줄링에는 SRT, MQ, RR, 비선점 스케줄링에는 FIFO, SJF, HRN 방식이 있습니다.

**Q. FIFO, SJF, HRN, SRT, RR, MQ 설명해보세요**

FIFO(FCFS)는 선입선출 방식으로 먼저 들어오면 먼저 나가는 방식입니다.

SJF는 평균 대기 시간을 최소화하기 위해 CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식입니다. 실행시간이 긴 프로세스의 할당 순위가 밀려 연기 상태에 빠질 수 있다는 단점이 있습니다.

HRN방식은 실행시간이 긴 프로세스에 불리한 SJF기법의 보완하기 위한 것으로 대기 시간과 서비스 시간을 고려하여 우선순위를 정하는 방식입니다. (이렇게 프로세스가 자원을 기다리는 시간에 비례하여 우선순위를 부여해 무한 연기의 문제를 방지하는 것을 **에이징 기법**이라고 함)

SRT는 SJF를 선점 형태로 변경한 것으로 중요한 프로세스가 있으면 점유시간이 길어도 먼저 실행시킬 수 있는 권한이 생기는 방식입니다.

RR은 프로세스들 사이에 우선순위를 두지 않고 순서대로 시간단위로 CPU를 할당하는 방식입니다. 응답시간이 짧아 실시간 시스템에 유리하지만 할당되는 시간이 클 경우 FIFO 기법과 같아지게 됩니다.

MQ는 프로세스를 특정 그룹으로 분류할 수 있을 경우 그룹에 따라 각기 다른 준비 상태 큐를 사용하는 기법입니다. 프로세스가 특정 그룹의 준비상태 큐에 들어갈 경우 다른 준비상태 큐로 이동할 수 없습니다. 

